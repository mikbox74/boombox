/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/scss/style.scss":
/*!*****************************!*\
  !*** ./src/scss/style.scss ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack:///./src/scss/style.scss?");

/***/ }),

/***/ "./src/abstracts/AudioSource.ts":
/*!**************************************!*\
  !*** ./src/abstracts/AudioSource.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ AudioSource)\n/* harmony export */ });\n/* harmony import */ var _abstracts_EmitterEventTarget__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/abstracts/EmitterEventTarget */ \"./src/abstracts/EmitterEventTarget.ts\");\n\nclass AudioSource extends _abstracts_EmitterEventTarget__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    plugIn() {\n        this.setMediaActions();\n    }\n    plugOut() {\n        this.resetMediaActions();\n        this.resetMediaMetadata();\n        this.resetMediaPlaybackState();\n        this.resetMediaPositionState();\n    }\n    setMediaActions() {\n        if (!('mediaSession' in navigator)) {\n            return;\n        }\n        try {\n            navigator.mediaSession.setActionHandler('play', (d) => this.commonMediaAction(d));\n            navigator.mediaSession.setActionHandler('pause', (d) => this.commonMediaAction(d));\n            navigator.mediaSession.setActionHandler('stop', (d) => this.commonMediaAction(d));\n            navigator.mediaSession.setActionHandler('seekbackward', (d) => this.commonMediaAction(d));\n            navigator.mediaSession.setActionHandler('seekforward', (d) => this.commonMediaAction(d));\n            navigator.mediaSession.setActionHandler('previoustrack', (d) => this.commonMediaAction(d));\n            navigator.mediaSession.setActionHandler('nexttrack', (d) => this.commonMediaAction(d));\n            navigator.mediaSession.setActionHandler('seekto', (d) => this.commonMediaAction(d));\n        }\n        catch (error) {\n            console.log(`${error.message}`);\n        }\n    }\n    ;\n    updateMediaMetadata() {\n        if (!('mediaSession' in navigator)) {\n            return;\n        }\n        // console.log(`updateMediaMetadata!`);\n        navigator.mediaSession.metadata = this.MediaMetadata;\n    }\n    updateMediaPositionState() {\n        if (!('mediaSession' in navigator) || this.audioElement.readyState < 3) {\n            return;\n        }\n        // console.log(`updateMediaPositionState!`);\n        const d = this.audioElement.duration;\n        navigator.mediaSession.setPositionState({\n            duration: d === Infinity ? this.audioElement.currentTime : d,\n            playbackRate: this.audioElement.playbackRate,\n            position: this.audioElement.currentTime,\n        });\n    }\n    updateMediaPlaybackState() {\n        if (!('mediaSession' in navigator)) {\n            return;\n        }\n        // console.log(`updateMediaPlaybackState!`);\n        if (!this.audioElement.paused) {\n            navigator.mediaSession.playbackState = 'playing';\n        }\n        else {\n            navigator.mediaSession.playbackState = 'paused';\n        }\n    }\n    resetMediaActions() {\n        if (!('mediaSession' in navigator)) {\n            return;\n        }\n        try {\n            navigator.mediaSession.setActionHandler('pause', () => false);\n            navigator.mediaSession.setActionHandler('stop', () => false);\n            navigator.mediaSession.setActionHandler('seekbackward', () => false);\n            navigator.mediaSession.setActionHandler('seekforward', () => false);\n            navigator.mediaSession.setActionHandler('previoustrack', () => false);\n            navigator.mediaSession.setActionHandler('nexttrack', () => false);\n            navigator.mediaSession.setActionHandler('seekto', () => false);\n        }\n        catch (error) {\n            console.log(`${error.message}`);\n        }\n    }\n    resetMediaPositionState() {\n        if (!('mediaSession' in navigator) || this.audioElement.readyState !== 4) {\n            return;\n        }\n        navigator.mediaSession.setPositionState({});\n    }\n    resetMediaMetadata() {\n        if (!('mediaSession' in navigator)) {\n            return;\n        }\n        navigator.mediaSession.metadata = new MediaMetadata({});\n    }\n    resetMediaPlaybackState() {\n        navigator.mediaSession.playbackState = 'none';\n    }\n}\n\n\n//# sourceURL=webpack:///./src/abstracts/AudioSource.ts?");

/***/ }),

/***/ "./src/abstracts/EmitterEventTarget.ts":
/*!*********************************************!*\
  !*** ./src/abstracts/EmitterEventTarget.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ EmitterEventTarget)\n/* harmony export */ });\nclass EmitterEventTarget extends EventTarget {\n    emit(event, data) {\n        return this.dispatchEvent(new CustomEvent(event, { detail: data }));\n    }\n}\n\n\n//# sourceURL=webpack:///./src/abstracts/EmitterEventTarget.ts?");

/***/ }),

/***/ "./src/classes/Amplifier.ts":
/*!**********************************!*\
  !*** ./src/classes/Amplifier.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Amplifier)\n/* harmony export */ });\nclass Amplifier extends EventTarget {\n    constructor(context) {\n        super();\n        this.init(context);\n    }\n    init(context) {\n        this.volumeNode = context.createGain();\n        this.balanceNode = new StereoPannerNode(context, { pan: 0 });\n        this.volumeNode.connect(this.balanceNode);\n    }\n    volume(value) {\n        if (value < 0) {\n            value = 0;\n        }\n        this.volumeNode.gain.value = value;\n    }\n    balance(value) {\n        if (value < -1) {\n            value = -1;\n        }\n        else if (value > 1) {\n            value = 1;\n        }\n        this.balanceNode.pan.value = value;\n    }\n    get Nodes() {\n        return [\n            this.volumeNode,\n            this.balanceNode,\n        ];\n    }\n    get InNode() {\n        return this.volumeNode;\n    }\n    get OutNode() {\n        return this.balanceNode;\n    }\n}\n\n\n//# sourceURL=webpack:///./src/classes/Amplifier.ts?");

/***/ }),

/***/ "./src/classes/Analyser.ts":
/*!*********************************!*\
  !*** ./src/classes/Analyser.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Analyser)\n/* harmony export */ });\nclass Analyser extends EventTarget {\n    constructor(context) {\n        super();\n        this.nodes = [];\n        this.init(context);\n    }\n    init(context) {\n        const analyser = context.createAnalyser();\n        this.nodes.push(analyser);\n    }\n    get Nodes() {\n        return this.nodes;\n    }\n    get InNode() {\n        return this.nodes[0];\n    }\n    get OutNode() {\n        return this.nodes[0];\n    }\n}\n\n\n//# sourceURL=webpack:///./src/classes/Analyser.ts?");

/***/ }),

/***/ "./src/classes/Boombox.ts":
/*!********************************!*\
  !*** ./src/classes/Boombox.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Device__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Device */ \"./src/classes/Device.ts\");\n/* harmony import */ var _Deck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Deck */ \"./src/classes/Deck.ts\");\n/* harmony import */ var _Receiver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Receiver */ \"./src/classes/Receiver.ts\");\n/* harmony import */ var _Amplifier__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Amplifier */ \"./src/classes/Amplifier.ts\");\n/* harmony import */ var _Equalizer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Equalizer */ \"./src/classes/Equalizer.ts\");\n/* harmony import */ var _Analyser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Analyser */ \"./src/classes/Analyser.ts\");\n/* harmony import */ var _types_DeckStates__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/types/DeckStates */ \"./src/types/DeckStates.ts\");\n/* harmony import */ var _types_DeckMode__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/types/DeckMode */ \"./src/types/DeckMode.ts\");\n/* harmony import */ var _functions_Sec2time__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @/functions/Sec2time */ \"./src/functions/Sec2time.js\");\n/* harmony import */ var _UiSounds__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./UiSounds */ \"./src/classes/UiSounds.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\n\nclass Boombox {\n    constructor(options) {\n        this.uiState = {};\n        Object.assign(this, options);\n        this.loadUiState();\n        this.initDevice();\n        this.bindErrors();\n        this.bindDeckCase();\n        this.bindKeys();\n        this.bindProgressbar();\n        this.bindTrackInfo();\n        this.bindPlaybackInfo();\n        this.bindAmplifierControls();\n        this.bindEqualizerControls();\n        this.bindAnalyser();\n        this.bindCodecsInfo();\n        this.bindPlaylist();\n        this.bindFunctionSwitcher();\n        this.bindRadioControls();\n        this.bindUiSounds();\n        document.querySelectorAll(`[data-open]`).forEach(node => {\n            const block = document.querySelector(node.getAttribute('data-open'));\n            node.addEventListener('click', () => {\n                block.style.setProperty('visibility', 'visible');\n                block.dispatchEvent(new CustomEvent('dialog.open', {}));\n            });\n        });\n        document.querySelectorAll(`[data-close]`).forEach(node => {\n            const block = document.querySelector(node.getAttribute('data-close'));\n            node.addEventListener('click', () => {\n                block.style.setProperty('visibility', 'hidden');\n                block.dispatchEvent(new CustomEvent('dialog.close', {}));\n            });\n        });\n    }\n    loadUiState() {\n        try {\n            this.uiState = JSON.parse(localStorage.getItem('BoomboxState'));\n        }\n        catch (_a) { }\n        if (!this.uiState) {\n            this.uiState = {};\n        }\n    }\n    saveUiState() {\n        clearTimeout(this.uiStateTimeout);\n        this.uiStateTimeout = setTimeout(() => {\n            localStorage.setItem('BoomboxState', JSON.stringify(this.uiState));\n        }, 1000);\n    }\n    setUiStateItem(key, value) {\n        this.uiState[key] = value;\n        this.saveUiState();\n    }\n    bindUiSounds() {\n        if (!this.sounds) {\n            return;\n        }\n        if (this.sounds.tuning) {\n            _UiSounds__WEBPACK_IMPORTED_MODULE_9__[\"default\"].create('tuning', this.sounds.tuning, true);\n            this.device.on('plugin-radio', () => _UiSounds__WEBPACK_IMPORTED_MODULE_9__[\"default\"].play('tuning'));\n            this.device.on('radio.loadstart', () => {\n                if (this.device.ActiveSourceName === 'radio') {\n                    _UiSounds__WEBPACK_IMPORTED_MODULE_9__[\"default\"].play('tuning');\n                }\n            });\n            this.device.on('radio.play', () => _UiSounds__WEBPACK_IMPORTED_MODULE_9__[\"default\"].stop('tuning'));\n            this.device.on('plugout-radio', () => _UiSounds__WEBPACK_IMPORTED_MODULE_9__[\"default\"].stop('tuning'));\n        }\n        const deck = this.device.getSource('deck');\n        if (this.sounds.play) {\n            _UiSounds__WEBPACK_IMPORTED_MODULE_9__[\"default\"].create('play', this.sounds.play);\n            document.querySelector(this.keys.play).addEventListener('mousedown', () => {\n                if (deck.State !== _types_DeckStates__WEBPACK_IMPORTED_MODULE_6__.DeckStates.playing) {\n                    _UiSounds__WEBPACK_IMPORTED_MODULE_9__[\"default\"].play('play');\n                }\n            });\n        }\n        if (this.sounds.stop) {\n            _UiSounds__WEBPACK_IMPORTED_MODULE_9__[\"default\"].create('stop', this.sounds.stop);\n            if (this.keys.stop) {\n                document.querySelector(this.keys.stop).addEventListener('mousedown', () => {\n                    if (deck.State !== _types_DeckStates__WEBPACK_IMPORTED_MODULE_6__.DeckStates.stopped) {\n                        _UiSounds__WEBPACK_IMPORTED_MODULE_9__[\"default\"].play('stop');\n                    }\n                });\n            }\n            if (this.keys.loadStop) {\n                document.querySelector(this.keys.loadStop).addEventListener('mousedown', () => {\n                    if (deck.State !== _types_DeckStates__WEBPACK_IMPORTED_MODULE_6__.DeckStates.stopped) {\n                        _UiSounds__WEBPACK_IMPORTED_MODULE_9__[\"default\"].play('stop');\n                    }\n                });\n            }\n        }\n        if (this.sounds.pauseOn) {\n            _UiSounds__WEBPACK_IMPORTED_MODULE_9__[\"default\"].create('pauseOn', this.sounds.pauseOn);\n            document.querySelector(this.keys.pause).addEventListener('mousedown', () => {\n                if (deck.State === _types_DeckStates__WEBPACK_IMPORTED_MODULE_6__.DeckStates.playing) {\n                    _UiSounds__WEBPACK_IMPORTED_MODULE_9__[\"default\"].play('pauseOn');\n                }\n            });\n        }\n        if (this.sounds.pauseOff) {\n            _UiSounds__WEBPACK_IMPORTED_MODULE_9__[\"default\"].create('pauseOff', this.sounds.pauseOff);\n            document.querySelector(this.keys.pause).addEventListener('mousedown', () => {\n                if (deck.State === _types_DeckStates__WEBPACK_IMPORTED_MODULE_6__.DeckStates.paused) {\n                    _UiSounds__WEBPACK_IMPORTED_MODULE_9__[\"default\"].play('pauseOff');\n                }\n            });\n        }\n        if (this.sounds.cassetteEject) {\n            _UiSounds__WEBPACK_IMPORTED_MODULE_9__[\"default\"].create('cassetteEject', this.sounds.cassetteEject);\n            if (this.keys.load) {\n                document.querySelector(this.keys.load).addEventListener('mousedown', () => {\n                    _UiSounds__WEBPACK_IMPORTED_MODULE_9__[\"default\"].play('cassetteEject');\n                });\n            }\n            if (this.keys.loadStop) {\n                document.querySelector(this.keys.loadStop).addEventListener('mousedown', () => {\n                    if (deck.State === _types_DeckStates__WEBPACK_IMPORTED_MODULE_6__.DeckStates.stopped) {\n                        _UiSounds__WEBPACK_IMPORTED_MODULE_9__[\"default\"].play('cassetteEject');\n                    }\n                });\n            }\n        }\n        if (this.sounds.cassetteLoad) {\n            _UiSounds__WEBPACK_IMPORTED_MODULE_9__[\"default\"].create('cassetteLoad', this.sounds.cassetteLoad);\n            this.device.on('deck.loaded', () => {\n                _UiSounds__WEBPACK_IMPORTED_MODULE_9__[\"default\"].play('cassetteLoad');\n            });\n            this.device.on('deck.cancel', () => {\n                _UiSounds__WEBPACK_IMPORTED_MODULE_9__[\"default\"].play('cassetteLoad');\n            });\n        }\n        if (this.sounds.otherKeys) {\n            _UiSounds__WEBPACK_IMPORTED_MODULE_9__[\"default\"].create('otherKeys', this.sounds.otherKeys);\n            if (this.keys.next) {\n                document.querySelector(this.keys.next)\n                    .addEventListener('mousedown', () => {\n                    _UiSounds__WEBPACK_IMPORTED_MODULE_9__[\"default\"].play('otherKeys');\n                });\n            }\n            if (this.keys.nextDirectory) {\n                document.querySelector(this.keys.nextDirectory)\n                    .addEventListener('mousedown', () => {\n                    _UiSounds__WEBPACK_IMPORTED_MODULE_9__[\"default\"].play('otherKeys');\n                });\n            }\n            if (this.keys.previous) {\n                document.querySelector(this.keys.previous)\n                    .addEventListener('mousedown', () => {\n                    _UiSounds__WEBPACK_IMPORTED_MODULE_9__[\"default\"].play('otherKeys');\n                });\n            }\n            if (this.keys.previousDirectory) {\n                document.querySelector(this.keys.previousDirectory)\n                    .addEventListener('mousedown', () => {\n                    _UiSounds__WEBPACK_IMPORTED_MODULE_9__[\"default\"].play('otherKeys');\n                });\n            }\n        }\n        if (this.sounds.buttons) {\n            _UiSounds__WEBPACK_IMPORTED_MODULE_9__[\"default\"].create('buttons', this.sounds.buttons);\n            if (this.keys.autostart) {\n                document.querySelector(this.keys.autostart)\n                    .addEventListener('mousedown', () => {\n                    _UiSounds__WEBPACK_IMPORTED_MODULE_9__[\"default\"].play('buttons');\n                });\n            }\n            if (this.keys.repeatTrackMode) {\n                document.querySelector(this.keys.repeatTrackMode)\n                    .addEventListener('mousedown', () => {\n                    _UiSounds__WEBPACK_IMPORTED_MODULE_9__[\"default\"].play('buttons');\n                });\n            }\n            if (this.keys.repeatDirMode) {\n                document.querySelector(this.keys.repeatDirMode)\n                    .addEventListener('mousedown', () => {\n                    _UiSounds__WEBPACK_IMPORTED_MODULE_9__[\"default\"].play('buttons');\n                });\n            }\n            if (this.keys.repeatDirMode) {\n                document.querySelector(this.keys.repeatDirMode)\n                    .addEventListener('mousedown', () => {\n                    _UiSounds__WEBPACK_IMPORTED_MODULE_9__[\"default\"].play('buttons');\n                });\n            }\n            if (this.keys.repeatAllMode) {\n                document.querySelector(this.keys.repeatAllMode)\n                    .addEventListener('mousedown', () => {\n                    _UiSounds__WEBPACK_IMPORTED_MODULE_9__[\"default\"].play('buttons');\n                });\n            }\n            if (this.function) {\n                document.querySelector(this.function.tape)\n                    .addEventListener('mousedown', () => {\n                    _UiSounds__WEBPACK_IMPORTED_MODULE_9__[\"default\"].play('buttons');\n                });\n                document.querySelector(this.function.radio)\n                    .addEventListener('mousedown', () => {\n                    _UiSounds__WEBPACK_IMPORTED_MODULE_9__[\"default\"].play('buttons');\n                });\n                document.querySelector(this.function.aux)\n                    .addEventListener('mousedown', () => {\n                    _UiSounds__WEBPACK_IMPORTED_MODULE_9__[\"default\"].play('buttons');\n                });\n            }\n        }\n    }\n    initDevice() {\n        var _a;\n        if (!window.AudioContext && !window.webkitAudioContext) {\n            document.querySelector(this.unsupported).style.visibility = 'visible';\n        }\n        const context = new (window.AudioContext || window.webkitAudioContext)();\n        const defaultSourseName = (_a = this.uiState['defaultSourseName']) !== null && _a !== void 0 ? _a : 'deck';\n        this.device = new _Device__WEBPACK_IMPORTED_MODULE_0__[\"default\"]([\n            ['deck', new _Deck__WEBPACK_IMPORTED_MODULE_1__[\"default\"](context)],\n            ['radio', new _Receiver__WEBPACK_IMPORTED_MODULE_2__[\"default\"](context)],\n            // ['aux', new Aux(context)],\n        ], [\n            ['analyser', new _Analyser__WEBPACK_IMPORTED_MODULE_5__[\"default\"](context)],\n            ['amplifier', new _Amplifier__WEBPACK_IMPORTED_MODULE_3__[\"default\"](context)],\n            ['equalizer', new _Equalizer__WEBPACK_IMPORTED_MODULE_4__[\"default\"](context, { bands: this.equalizer })],\n        ], defaultSourseName);\n        this.device.on('radio.loaded', () => {\n            const radio = this.device.getSource('radio');\n            let pos = 0;\n            if (typeof this.uiState['radioStationId'] !== 'undefined') {\n                pos = radio.Playlist.getPositionById(this.uiState['radioStationId']);\n            }\n            if (this.device.ActiveSourceName === 'radio') {\n                radio.playFromPosition(pos);\n            }\n            else {\n                radio.Playlist.Position = pos;\n            }\n        }, { once: true });\n        const deck = this.device.getSource('deck');\n        deck.autoplay = !!this.uiState.autoplay;\n    }\n    bindDeckCase() {\n        if (!this.cassetteDeckCase) {\n            return;\n        }\n        const element = document.querySelector(this.cassetteDeckCase.selector);\n        if (this.cassetteDeckCase.openClass) {\n            this.device.on('deck.open', () => {\n                element.classList.add(this.cassetteDeckCase.openClass);\n            });\n            this.device.on('deck.loaded', () => {\n                element.classList.remove(this.cassetteDeckCase.openClass);\n            });\n            this.device.on('deck.notpicked', () => {\n                element.classList.remove(this.cassetteDeckCase.openClass);\n            });\n            this.device.on('deck.cancel', () => {\n                element.classList.remove(this.cassetteDeckCase.openClass);\n            });\n            this.device.on('deck.closedbyfallback', () => {\n                element.classList.remove(this.cassetteDeckCase.openClass);\n            });\n        }\n        if (this.cassetteDeckCase.loadedClass) {\n            this.device.on('deck.loaded', () => {\n                element.classList.add(this.cassetteDeckCase.loadedClass);\n            });\n        }\n        if (this.cassetteDeckCase.workingClass) {\n            this.device.on('deck.play', () => {\n                element.classList.add(this.cassetteDeckCase.workingClass);\n            });\n            this.device.on('deck.pause-off', () => {\n                element.classList.add(this.cassetteDeckCase.workingClass);\n            });\n            this.device.on('deck.pause-on', () => {\n                element.classList.remove(this.cassetteDeckCase.workingClass);\n            });\n            this.device.on('deck.stop', () => {\n                element.classList.remove(this.cassetteDeckCase.workingClass);\n            });\n        }\n        if (!this.cassetteDeckCase.tapeLeft && !this.cassetteDeckCase.tapeRight) {\n            return;\n        }\n        let trackDuration = 0;\n        let tapeLeftElement;\n        let tapeRightElement;\n        let leftTapeWidth = this.cassetteDeckCase.maxTapeWidth;\n        let rightTapeWidth = this.cassetteDeckCase.minTapeWidth;\n        let diffWidth = leftTapeWidth - rightTapeWidth;\n        const deck = this.device.getSource('deck');\n        if (this.cassetteDeckCase.tapeLeft) {\n            tapeLeftElement = document.querySelector(this.cassetteDeckCase.tapeLeft);\n        }\n        if (this.cassetteDeckCase.tapeRight) {\n            tapeRightElement = document.querySelector(this.cassetteDeckCase.tapeRight);\n        }\n        const resetTapeWidth = () => {\n            trackDuration = deck.Track.duration;\n            if (tapeLeftElement) {\n                tapeLeftElement.style.setProperty('width', `${leftTapeWidth}px`);\n            }\n            if (tapeRightElement) {\n                tapeRightElement.style.setProperty('width', `${rightTapeWidth}px`);\n            }\n        };\n        this.device.on('deck.loadeddata', () => {\n            requestAnimationFrame(resetTapeWidth);\n        });\n        const recalcTapeWidth = (time) => {\n            let incrW = diffWidth * time / trackDuration;\n            let leftWidth = leftTapeWidth - incrW;\n            if (tapeLeftElement && (leftWidth >= this.cassetteDeckCase.minTapeWidth)) {\n                tapeLeftElement.style.setProperty('width', `${leftWidth}px`);\n            }\n            let rightWidth = rightTapeWidth + incrW;\n            if (tapeRightElement && (rightWidth <= this.cassetteDeckCase.maxTapeWidth)) {\n                tapeRightElement.style.setProperty('width', `${rightTapeWidth + incrW}px`);\n            }\n        };\n        this.device.on('deck.timeupdate', (event) => {\n            requestAnimationFrame(() => recalcTapeWidth(event.detail.time));\n        });\n        // let reelLeftElement: HTMLElement;\n        // let maxReelSpeed = this.cassetteDeckCase.maxReelSpeed;\n        // let minReelSpeed = this.cassetteDeckCase.minReelSpeed;\n        // let diffSpeed = maxReelSpeed - minReelSpeed;\n        // if (this.cassetteDeckCase.reelLeft) {\n        //   reelLeftElement = document.querySelector(this.cassetteDeckCase.reelLeft);\n        // }\n        // this.device.on('deck.loadeddata', () => {\n        //   if (reelLeftElement) {\n        //     reelLeftElement.style.setProperty('animation-duration', `${minReelSpeed}s`);\n        //   }\n        // });\n        // this.device.on('deck.timeupdate', (event:CustomEvent) => {\n        //   let incrS = diffSpeed*event.detail.time/trackDuration;\n        //   if (reelLeftElement) {\n        //     reelLeftElement.style.setProperty(\n        //       'animation-duration', `${minReelSpeed + incrS}s`\n        //     );\n        //   }\n        // });\n    }\n    bindKeys() {\n        const deck = this.device.getSource('deck');\n        this.key(this.keys.play, (e) => {\n            if (deck.State === _types_DeckStates__WEBPACK_IMPORTED_MODULE_6__.DeckStates.stopped) {\n                return deck.play();\n            }\n            if (deck.State === _types_DeckStates__WEBPACK_IMPORTED_MODULE_6__.DeckStates.paused) {\n                return deck.pause();\n            }\n        }, ['deck.play'], ['deck.stop']);\n        this.key(this.keys.stop, {\n            click: (e) => {\n                if (deck.State !== _types_DeckStates__WEBPACK_IMPORTED_MODULE_6__.DeckStates.stopped) {\n                    deck.stop();\n                }\n            },\n            mousedown: (e) => e.target.classList.add(this.classes.pressedKey),\n            mouseup: (e) => e.target.classList.remove(this.classes.pressedKey),\n        });\n        this.key(this.keys.loadStop, {\n            click: (e) => {\n                if (deck.State === _types_DeckStates__WEBPACK_IMPORTED_MODULE_6__.DeckStates.stopped) {\n                    if (this.cassetteDeckCase && this.cassetteDeckCase.openClass) {\n                        const el = document.querySelector(this.cassetteDeckCase.selector);\n                        el.addEventListener('transitionend', () => {\n                            deck.load(true);\n                        }, { once: true });\n                        el.classList.add(this.cassetteDeckCase.openClass);\n                        return;\n                    }\n                    deck.load(true);\n                }\n                else {\n                    deck.stop();\n                }\n            },\n            contextmenu: (e) => {\n                if (deck.State === _types_DeckStates__WEBPACK_IMPORTED_MODULE_6__.DeckStates.stopped) {\n                    deck.load();\n                }\n            },\n            mousedown: (e) => e.target.classList.add(this.classes.pressedKey),\n            mouseup: (e) => e.target.classList.remove(this.classes.pressedKey),\n        }, [], ['deck.loaded', 'deck.cancel', 'deck.notpicked']);\n        this.key(this.keys.load, {\n            click: (e) => deck.load(),\n            contextmenu: (e) => deck.load(true),\n            mousedown: (e) => e.target.classList.add(this.classes.pressedKey),\n            mouseup: (e) => e.target.classList.remove(this.classes.pressedKey),\n        }, [], ['deck.loaded', 'deck.cancel', 'deck.notpicked']);\n        this.key(this.keys.pause, (e) => {\n            deck.pause();\n        }, ['deck.pause-on'], ['deck.pause-off', 'deck.stop', 'deck.play']);\n        this.key(this.keys.previous, {\n            click: (e) => deck.previous(),\n            mousedown: (e) => e.target.classList.add(this.classes.pressedKey),\n            mouseup: (e) => e.target.classList.remove(this.classes.pressedKey),\n        });\n        this.key(this.keys.next, {\n            click: (e) => deck.next(),\n            mousedown: (e) => e.target.classList.add(this.classes.pressedKey),\n            mouseup: (e) => e.target.classList.remove(this.classes.pressedKey),\n        });\n        this.key(this.keys.previousDirectory, {\n            click: (e) => deck.previousDirectory(),\n            mousedown: (e) => e.target.classList.add(this.classes.pressedKey),\n            mouseup: (e) => e.target.classList.remove(this.classes.pressedKey),\n        });\n        this.key(this.keys.nextDirectory, {\n            click: (e) => deck.nextDirectory(),\n            mousedown: (e) => e.target.classList.add(this.classes.pressedKey),\n            mouseup: (e) => e.target.classList.remove(this.classes.pressedKey),\n        });\n        // this.key(this.keys.record, (e:any) => {\n        //   deck.record();\n        // });\n        let repeatAllIndicator;\n        let repeatDirIndicator;\n        let repeatTrkIndicator;\n        let autostartIndicator;\n        if (this.indicators) {\n            if (this.indicators.repeatAll) {\n                repeatAllIndicator = document.querySelector(this.indicators.repeatAll);\n            }\n            if (this.indicators.repeatDir) {\n                repeatDirIndicator = document.querySelector(this.indicators.repeatDir);\n            }\n            if (this.indicators.repeatTrack) {\n                repeatTrkIndicator = document.querySelector(this.indicators.repeatTrack);\n            }\n            if (this.indicators.autostart) {\n                autostartIndicator = document.querySelector(this.indicators.autostart);\n            }\n        }\n        const removePressedClassFromRepeatButtons = () => {\n            if (!this.classes || !this.classes.pressedKey) {\n                return;\n            }\n            if (this.keys.repeatAllMode) {\n                document\n                    .querySelector(this.keys.repeatAllMode)\n                    .classList.remove(this.classes.pressedKey);\n            }\n            if (this.keys.repeatDirMode) {\n                document\n                    .querySelector(this.keys.repeatDirMode)\n                    .classList.remove(this.classes.pressedKey);\n            }\n            if (this.keys.repeatTrackMode) {\n                document\n                    .querySelector(this.keys.repeatTrackMode)\n                    .classList.remove(this.classes.pressedKey);\n            }\n        };\n        const removeOnClassFromRepeatLeds = () => {\n            if (repeatAllIndicator) {\n                repeatAllIndicator.classList.remove(this.indicators.onClass);\n            }\n            if (repeatDirIndicator) {\n                repeatDirIndicator.classList.remove(this.indicators.onClass);\n            }\n            if (repeatTrkIndicator) {\n                repeatTrkIndicator.classList.remove(this.indicators.onClass);\n            }\n        };\n        this.key(this.keys.repeatAllMode, (e) => {\n            removePressedClassFromRepeatButtons();\n            removeOnClassFromRepeatLeds();\n            if (deck.playbackMode === _types_DeckMode__WEBPACK_IMPORTED_MODULE_7__.DeckMode.repeatAll) {\n                deck.setPlaybackMode(_types_DeckMode__WEBPACK_IMPORTED_MODULE_7__.DeckMode[\"default\"]);\n                return;\n            }\n            deck.setPlaybackMode(_types_DeckMode__WEBPACK_IMPORTED_MODULE_7__.DeckMode.repeatAll);\n            if (this.classes && this.classes.pressedKey) {\n                e.target.classList.add(this.classes.pressedKey);\n            }\n            if (repeatAllIndicator) {\n                repeatAllIndicator.classList.add(this.indicators.onClass);\n            }\n        });\n        this.key(this.keys.repeatDirMode, (e) => {\n            removePressedClassFromRepeatButtons();\n            removeOnClassFromRepeatLeds();\n            if (deck.playbackMode === _types_DeckMode__WEBPACK_IMPORTED_MODULE_7__.DeckMode.repeatDir) {\n                deck.setPlaybackMode(_types_DeckMode__WEBPACK_IMPORTED_MODULE_7__.DeckMode[\"default\"]);\n                return;\n            }\n            deck.setPlaybackMode(_types_DeckMode__WEBPACK_IMPORTED_MODULE_7__.DeckMode.repeatDir);\n            if (this.classes && this.classes.pressedKey) {\n                e.target.classList.add(this.classes.pressedKey);\n            }\n            if (repeatDirIndicator) {\n                repeatDirIndicator.classList.add(this.indicators.onClass);\n            }\n        });\n        this.key(this.keys.repeatTrackMode, (e) => {\n            removePressedClassFromRepeatButtons();\n            removeOnClassFromRepeatLeds();\n            if (deck.playbackMode === _types_DeckMode__WEBPACK_IMPORTED_MODULE_7__.DeckMode.repeatTrack) {\n                deck.setPlaybackMode(_types_DeckMode__WEBPACK_IMPORTED_MODULE_7__.DeckMode[\"default\"]);\n                return;\n            }\n            deck.setPlaybackMode(_types_DeckMode__WEBPACK_IMPORTED_MODULE_7__.DeckMode.repeatTrack);\n            if (this.classes && this.classes.pressedKey) {\n                e.target.classList.add(this.classes.pressedKey);\n            }\n            if (repeatTrkIndicator) {\n                repeatTrkIndicator.classList.add(this.indicators.onClass);\n            }\n        });\n        if (this.keys.autostart) {\n            const uiHandler = (button) => {\n                if (!deck.autoplay) {\n                    if (this.classes && this.classes.pressedKey) {\n                        button.classList.remove(this.classes.pressedKey);\n                    }\n                    if (autostartIndicator) {\n                        autostartIndicator.classList.remove(this.indicators.onClass);\n                    }\n                }\n                else {\n                    if (this.classes && this.classes.pressedKey) {\n                        button.classList.add(this.classes.pressedKey);\n                    }\n                    if (autostartIndicator) {\n                        autostartIndicator.classList.add(this.indicators.onClass);\n                    }\n                }\n            };\n            this.key(this.keys.autostart, (e) => {\n                deck.autoplay = !deck.autoplay;\n                this.setUiStateItem('autoplay', !deck.autoplay ? '' : '1');\n                uiHandler(e.target);\n            });\n            const button = document.querySelector(this.keys.autostart);\n            if (button) {\n                uiHandler(button);\n            }\n        }\n    }\n    bindProgressbar() {\n        if (!this.track) {\n            return;\n        }\n        const deck = this.device.getSource('deck');\n        let trackDuration = 0;\n        let cursorBusy = false;\n        if (this.track.bar) {\n            const progressBar = document.querySelector(this.track.bar);\n            let progressLeft = 0;\n            let progressWidth = 0;\n            const measureProgressElement = () => {\n                requestAnimationFrame(() => {\n                    progressLeft = progressBar.parentElement.getBoundingClientRect().x;\n                    progressWidth = progressBar.parentElement.clientWidth;\n                });\n            };\n            measureProgressElement();\n            window.addEventListener('resize', measureProgressElement);\n            progressBar.addEventListener('click', (event) => {\n                event.preventDefault();\n                if (cursorBusy) {\n                    return;\n                }\n                requestAnimationFrame(() => {\n                    let clientX = event.clientX;\n                    let newPos = Math.min(((clientX - progressLeft) / progressWidth * 100), 100);\n                    if (newPos < 0) {\n                        newPos = 0;\n                    }\n                    else if (newPos > 100) {\n                        newPos = 100;\n                    }\n                    deck.Track.currentTime = trackDuration * (newPos / 100);\n                });\n            });\n            if (this.track.head) {\n                let clientX = 0;\n                let cursorNode = document.querySelector(this.track.head);\n                this.device.on('deck.stop', () => {\n                    cursorNode.style.transform = `translateX(0px)`;\n                });\n                this.device.on('deck.timeupdate', (event) => {\n                    if (!trackDuration || cursorBusy) {\n                        return;\n                    }\n                    let pos = Math.round(progressWidth * event.detail.time / trackDuration);\n                    cursorNode.style.transform = `translateX(${pos}px)`;\n                });\n                cursorNode.addEventListener('mousedown', (event) => {\n                    requestAnimationFrame(() => clientX = event.clientX);\n                    cursorBusy = true;\n                    window.addEventListener('mouseup', (event) => {\n                        cursorBusy = false;\n                    }, { once: true });\n                });\n                window.addEventListener('mousemove', (event) => {\n                    if (!cursorBusy) {\n                        return;\n                    }\n                    requestAnimationFrame(() => {\n                        clientX = event.clientX;\n                        let pixelPos = clientX - progressLeft;\n                        let newPos = pixelPos / progressWidth * 100;\n                        if (newPos < 0) {\n                            newPos = 0;\n                            pixelPos = 0;\n                        }\n                        else if (newPos > 100) {\n                            newPos = 100;\n                            pixelPos = progressWidth;\n                        }\n                        cursorNode.style.transform = `translateX(${pixelPos}px)`;\n                        deck.Track.currentTime = trackDuration * (newPos / 100);\n                    });\n                });\n            }\n            if (this.track.mark) {\n                const calcPos = (event, progressLeft, progressWidth) => {\n                    let newPos = event.clientX - progressLeft;\n                    if (newPos < 0) {\n                        newPos = 0;\n                    }\n                    if (newPos > progressWidth) {\n                        newPos = progressWidth;\n                    }\n                    return newPos;\n                };\n                let over = false;\n                let markNode = document.querySelector(this.track.mark);\n                progressBar.addEventListener('mouseover', (event) => {\n                    over = true;\n                    requestAnimationFrame(() => {\n                        let newPos = calcPos(event, progressLeft, progressWidth);\n                        markNode.style.opacity = '1';\n                        markNode.style.transform = `translateX(${newPos}px)`;\n                    });\n                });\n                progressBar.addEventListener('mouseout', () => {\n                    over = false;\n                    markNode.style.opacity = '0';\n                    markNode.style.transform = `translateX(0px)`;\n                });\n                progressBar.addEventListener('mousemove', (event) => {\n                    if (cursorBusy || !over) {\n                        return;\n                    }\n                    requestAnimationFrame(() => {\n                        let newPos = calcPos(event, progressLeft, progressWidth);\n                        markNode.textContent = (0,_functions_Sec2time__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(trackDuration * (newPos / progressWidth));\n                        markNode.style.transform = `translateX(${newPos}px)`;\n                    });\n                });\n            }\n            this.device.on('deck.loadstart', () => {\n                progressBar.style.transform = 'scaleX(0)';\n                if (this.classes && this.classes.barTransition) {\n                    requestAnimationFrame(() => progressBar.classList.add(this.classes.barTransition));\n                }\n            });\n            this.device.on('deck.progress', (event) => {\n                const nativeEvent = event.detail.nativeEvent;\n                const value = nativeEvent.loaded / nativeEvent.total;\n                progressBar.style.transform = 'scaleX(' + (value / 1.5) + ')';\n            });\n            this.device.on('deck.loadeddata', () => {\n                trackDuration = deck.Track.duration;\n                progressBar.style.transform = 'scaleX(1)';\n                if (this.classes && this.classes.barTransition) {\n                    requestAnimationFrame(() => progressBar.classList.remove(this.classes.barTransition));\n                }\n            });\n        }\n    }\n    bindTrackInfo() {\n        if (!this.info) {\n            return;\n        }\n        const deck = this.device.getSource('deck');\n        let trackNameNode;\n        let trackTimeNode;\n        let trackPathNode;\n        if (this.info.name) {\n            trackNameNode = document.querySelector(this.info.name);\n        }\n        if (this.info.duration) {\n            trackTimeNode = document.querySelector(this.info.duration);\n        }\n        if (this.info.path) {\n            trackPathNode = document.querySelector(this.info.path);\n        }\n        if (trackNameNode) {\n            this.device.on('deck.trackchanged', (e) => {\n                if (!this.playlist.nameFormat || (e.detail.position !== deck.Playlist.Position)) {\n                    return;\n                }\n                trackNameNode.setAttribute('data-marquee', this.playlist.nameFormat(deck.Playlist.Entry.tags) || deck.Playlist.Entry.name);\n            });\n            this.device.on('deck.loadstart', () => {\n                if (!this.playlist.nameFormat) {\n                    return;\n                }\n                trackNameNode.setAttribute('data-marquee', this.playlist.nameFormat(deck.Playlist.Entry.tags) || deck.Playlist.Entry.name);\n            });\n            this.device.on('deck.cancel', () => {\n                trackNameNode.setAttribute('data-marquee', '-');\n            });\n        }\n        if (trackTimeNode) {\n            this.device.on('deck.loadeddata', () => {\n                trackTimeNode.textContent = (0,_functions_Sec2time__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(Math.round(deck.Track.duration));\n            });\n            this.device.on('deck.cancel', () => {\n                trackTimeNode.textContent = '--:--';\n            });\n        }\n        if (trackPathNode) {\n            this.device.on('deck.loadstart', () => {\n                if (deck.Playlist.Entry.path) {\n                    trackPathNode.textContent = deck.Playlist.Entry.path.join(' / ');\n                }\n                else {\n                    trackPathNode.textContent = '-';\n                }\n            });\n            this.device.on('deck.cancel', () => {\n                trackPathNode.textContent = '-';\n            });\n        }\n    }\n    bindPlaybackInfo() {\n        if (!this.info) {\n            return;\n        }\n        const deck = this.device.getSource('deck');\n        let functionInfoNode;\n        let dataInfoNode;\n        if (this.info.function) {\n            functionInfoNode = document.querySelector(this.info.function);\n        }\n        if (this.info.data) {\n            dataInfoNode = document.querySelector(this.info.data);\n        }\n        if (functionInfoNode) {\n            // Pause state\n            this.device.on('deck.pause-on', () => {\n                functionInfoNode.textContent = 'Paused';\n            });\n            this.device.on('deck.pause-off', () => {\n                functionInfoNode.textContent = 'Playback';\n            });\n            // Stop\n            this.device.on('deck.stop', () => {\n                functionInfoNode.textContent = 'Stopped';\n            });\n            // Loading\n            this.device.on('deck.loadstart', () => {\n                functionInfoNode.textContent = 'Start reading...';\n            });\n            this.device.on('deck.progress', () => {\n                functionInfoNode.textContent = 'Track reading...';\n            });\n            this.device.on('deck.loadeddata', () => {\n                functionInfoNode.textContent = 'Ready';\n            });\n            // Playing\n            this.device.on('deck.timeupdate', () => {\n                if (deck.State === _types_DeckStates__WEBPACK_IMPORTED_MODULE_6__.DeckStates.playing) {\n                    functionInfoNode.textContent = 'Playback';\n                }\n            });\n        }\n        if (dataInfoNode) {\n            // Stop\n            this.device.on('deck.stop', () => {\n                dataInfoNode.textContent = '--';\n            });\n            // Loading\n            this.device.on('deck.loadstart', () => {\n                dataInfoNode.textContent = '0%';\n            });\n            this.device.on('deck.progress', (event) => {\n                const nativeEvent = event.detail.nativeEvent;\n                const value = nativeEvent.loaded / nativeEvent.total;\n                dataInfoNode.textContent = Math.round(value / 1.5 / 100) + '%';\n            });\n            this.device.on('deck.loadeddata', () => {\n                dataInfoNode.textContent = '100%';\n            });\n            // Playing\n            this.device.on('deck.timeupdate', (event) => {\n                const elapsed = Math.round(event.detail.time);\n                const remain = Math.round(deck.Track.duration) - elapsed;\n                dataInfoNode.textContent = `${(0,_functions_Sec2time__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(elapsed)} / ${(0,_functions_Sec2time__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(remain)}`;\n            });\n        }\n    }\n    bindAnalyser() {\n        if ((!this.analyser) &&\n            (!this.bassdrivers || !this.bassdrivers.levels)) {\n            return;\n        }\n        const leds = new Map();\n        if (this.analyser && this.analyser.leds) {\n            this.analyser.leds.forEach(led => {\n                leds.set(led.thereshold, document.querySelector(led.selector));\n            });\n        }\n        let leftDriverNode;\n        let rightDriverNode;\n        if (this.bassdrivers.left) {\n            leftDriverNode = document.querySelector(this.bassdrivers.left);\n        }\n        if (this.bassdrivers.right) {\n            rightDriverNode = document.querySelector(this.bassdrivers.right);\n        }\n        const resetProp = this.bassdrivers.reset[0];\n        const resetValue = this.bassdrivers.reset[1];\n        const component = this.device.getComponent('analyser');\n        const analyser = component.Nodes[0];\n        analyser.fftSize = 256;\n        let dataArray = new Float32Array(analyser.fftSize);\n        let requestId;\n        const offset = this.analyser.offset;\n        const minOpacity = this.analyser.minOpacity ? this.analyser.minOpacity : '0.1';\n        const maxOpacity = this.analyser.maxOpacity ? this.analyser.maxOpacity : '1';\n        const draw = () => {\n            analyser.getFloatTimeDomainData(dataArray);\n            let peakInstantaneousPower = 0;\n            let peakInstantaneousBassPower = 0;\n            for (let i = 0; i < dataArray.length / 4; i++) {\n                peakInstantaneousPower = Math.max(Math.pow(dataArray[i], 2), peakInstantaneousPower);\n                if (i == 0) {\n                    peakInstantaneousBassPower = peakInstantaneousPower;\n                }\n            }\n            const value = 10 * Math.log10(peakInstantaneousPower);\n            const bassValue = 10 * Math.log10(peakInstantaneousBassPower);\n            // let sumOfSquares = 0;\n            // for (let i = 0; i < dataArray.length; i++) {\n            //   sumOfSquares += dataArray[i] ** 2;\n            // }\n            // const value = 10 * Math.log10(sumOfSquares / dataArray.length);\n            if (leds.size) {\n                for (let led of leds) {\n                    let [thereshold, element] = led;\n                    element.style.opacity = minOpacity;\n                    if ((value + offset) >= thereshold) {\n                        element.style.opacity = maxOpacity;\n                    }\n                }\n            }\n            if (leftDriverNode || rightDriverNode) {\n                let p = resetProp, v = resetValue, thereshold;\n                for (let lvl of this.bassdrivers.levels) {\n                    [thereshold] = lvl;\n                    if ((bassValue + offset) >= thereshold) {\n                        [, p, v] = lvl;\n                        break;\n                    }\n                }\n                leftDriverNode ? leftDriverNode.style.setProperty(p, v) : null;\n                rightDriverNode ? rightDriverNode.style.setProperty(p, v) : null;\n            }\n            requestId = requestAnimationFrame(draw);\n        };\n        const stop = () => {\n            for (let led of leds) {\n                let [, element] = led;\n                element.style.opacity = minOpacity;\n            }\n            leftDriverNode ? leftDriverNode.style.setProperty(resetProp, resetValue) : null;\n            rightDriverNode ? rightDriverNode.style.setProperty(resetProp, resetValue) : null;\n            cancelAnimationFrame(requestId);\n        };\n        this.device.on('deck.play', () => {\n            draw();\n        });\n        this.device.on('deck.pause-off', () => {\n            draw();\n        });\n        this.device.on('radio.play', () => {\n            draw();\n        });\n        this.device.on('deck.pause-on', () => {\n            stop();\n        });\n        this.device.on('deck.stop', () => {\n            stop();\n        });\n        this.device.on('radio.stop', () => {\n            stop();\n        });\n    }\n    bindAmplifierControls() {\n        const amp = this.device.getComponent('amplifier');\n        this.potentiometer(this.volume, (v) => amp.volume(v));\n        this.potentiometer(this.balance, (v) => amp.balance(v));\n    }\n    bindEqualizerControls() {\n        if (this.equalizer) {\n            const eq = this.device.getComponent('equalizer');\n            this.equalizer.forEach(({ selector }, i) => {\n                this.potentiometer(selector, (v) => eq.gain(i, v));\n            });\n        }\n    }\n    bindCodecsInfo() {\n        if (!this.codecs || !this.codecs.selector) {\n            return;\n        }\n        const infoNode = document.querySelector(this.codecs.selector);\n        if (!infoNode) {\n            return;\n        }\n        const deck = this.device.getSource('deck');\n        requestAnimationFrame(() => {\n            deck.SupportedCodecs.forEach(codec => {\n                const codecNode = document.createElement('DIV');\n                codecNode.textContent = codec.name;\n                codecNode.className = 'codec-type-' + codec.type;\n                infoNode.appendChild(codecNode);\n            });\n        });\n    }\n    bindPlaylist() {\n        if (!this.playlist) {\n            return;\n        }\n        let previousPosition = 0;\n        const playlistElement = document.querySelector(this.playlist.selector);\n        const container = document.createElement('TEMPLATE');\n        const addItem = (index, name, HTML) => {\n            requestAnimationFrame(() => {\n                container.innerHTML = HTML;\n                container.content.firstChild.setAttribute('data-playlist-index', index);\n                const nameEl = container.content.firstChild.querySelector('[data-name]');\n                nameEl ? (nameEl.textContent = name) : null;\n                playlistElement.appendChild(container.content.firstChild);\n            });\n        };\n        const setItemDuration = (index, duration) => {\n            const timeEl = playlistElement.children[index].querySelector('[data-time]');\n            timeEl ? (timeEl.textContent = duration) : null;\n        };\n        const setItemFailed = (index) => {\n            const timeEl = playlistElement.children[index].querySelector('[data-time]');\n            timeEl ? (timeEl.textContent = 'ERROR') : null;\n            if (this.classes.failedItem) {\n                playlistElement.children[index].classList.add(this.classes.failedItem);\n            }\n        };\n        const setItemName = (index, tagInfo) => {\n            if (!tagInfo || !tagInfo.tags) {\n                return;\n            }\n            const newName = this.playlist.nameFormat(tagInfo);\n            if (!newName) {\n                return;\n            }\n            const nameEl = playlistElement.children[index].querySelector('[data-name]');\n            nameEl ? (nameEl.textContent = newName) : null;\n        };\n        this.device.on('deck.trackchanged', (e) => {\n            setItemName(e.detail.position, e.detail.tags);\n        });\n        this.device.on('deck.tracktimechanged', (e) => {\n            if (e.detail.duration) {\n                setItemDuration(e.detail.position, (0,_functions_Sec2time__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(Math.round(e.detail.duration)));\n            }\n            else {\n                setItemFailed(e.detail.position);\n            }\n        });\n        this.device.on('deck.loaded', (event) => __awaiter(this, void 0, void 0, function* () {\n            // Create playlist\n            playlistElement.innerHTML = '';\n            previousPosition = 0;\n            // console.time('List Rendering');\n            for (let i = 0; i < event.detail.playlist.length; i++) {\n                let item = event.detail.playlist[i];\n                if (item.kind !== 'directory') {\n                    addItem(i, item.name, this.playlist.trackHTML);\n                }\n                else {\n                    addItem(i, item.name, this.playlist.directoryHTML);\n                }\n            }\n        }));\n        const deck = this.device.getSource('deck');\n        playlistElement.addEventListener('click', (event) => {\n            if (this.device.ActiveSourceName !== 'deck') {\n                this.device.plugIn('deck');\n            }\n            const path = event.path || (event.composedPath && event.composedPath());\n            for (let i = 0; i < path.length; i++) {\n                if (path[i].hasAttribute && path[i].hasAttribute('data-playlist-index')) {\n                    deck.playFromPosition(parseInt(path[i].getAttribute('data-playlist-index'), 10));\n                    break;\n                }\n            }\n        });\n        if (this.classes && this.classes.activeItem) {\n            this.device.on('deck.play', (event) => __awaiter(this, void 0, void 0, function* () {\n                if (previousPosition !== event.detail.position) {\n                    playlistElement.children[previousPosition].classList.remove(this.classes.activeItem);\n                }\n                previousPosition = event.detail.position;\n                playlistElement.children[event.detail.position].classList.add(this.classes.activeItem);\n                playlistElement.children[event.detail.position].scrollIntoView({\n                    behavior: 'smooth',\n                    block: 'center'\n                });\n            }));\n        }\n    }\n    bindFunctionSwitcher() {\n        if (this.function) {\n            const tapeElement = this.key(this.function.tape, () => {\n                if (this.device.ActiveSourceName === 'deck') {\n                    return;\n                }\n                this.device.plugIn('deck');\n            }, ['plugin-deck'], ['plugout-deck']);\n            const radioElement = this.key(this.function.radio, () => {\n                if (this.device.ActiveSourceName === 'radio') {\n                    return;\n                }\n                this.device.plugIn('radio');\n            }, ['plugin-radio'], ['plugout-radio']);\n            this.device.on('plugin-radio', () => this.setUiStateItem('defaultSourseName', 'radio'));\n            this.device.on('plugin-deck', () => this.setUiStateItem('defaultSourseName', 'deck'));\n            switch (this.device.ActiveSourceName) {\n                case 'deck':\n                    tapeElement.classList.add(this.classes.pressedKey);\n                    break;\n                case 'radio':\n                    radioElement.classList.add(this.classes.pressedKey);\n                    break;\n            }\n        }\n    }\n    bindRadioControls() {\n        if (!this.radio) {\n            return;\n        }\n        if (this.indicators && this.indicators.stereo) {\n            const indicator = document.querySelector(this.indicators.stereo);\n            this.device.on('radio.play', () => {\n                indicator.classList.add(this.indicators.onClass);\n            });\n            this.device.on('radio.stop', () => {\n                indicator.classList.remove(this.indicators.onClass);\n            });\n            this.device.on('radio.loadstart', () => {\n                indicator.classList.remove(this.indicators.onClass);\n            });\n        }\n        let form;\n        let idInput;\n        let nameInput;\n        let urlInput;\n        let parserInput;\n        let paramsInput;\n        if (this.radio.form) {\n            form = document.querySelector(this.radio.form);\n            idInput = form.querySelector(`[name=\"station-id\"]`);\n            nameInput = form.querySelector(`[name=\"station-name\"]`);\n            urlInput = form.querySelector(`[name=\"station-url\"]`);\n            parserInput = form.querySelector(`[name=\"station-parser\"]`);\n            paramsInput = form.querySelector(`[name=\"station-params\"]`);\n        }\n        const radio = this.device.getSource('radio');\n        const prevButtonElement = document.querySelector(this.radio.prevButton);\n        const nextButtonElement = document.querySelector(this.radio.nextButton);\n        prevButtonElement.addEventListener('click', (e) => {\n            if (this.device.ActiveSourceName !== 'radio') {\n                return;\n            }\n            radio.previous();\n        });\n        nextButtonElement.addEventListener('click', (e) => {\n            if (this.device.ActiveSourceName !== 'radio') {\n                return;\n            }\n            radio.next();\n        });\n        if (this.radio.scaleRangeInput) {\n            const scaleRangeElement = document.querySelector(this.radio.scaleRangeInput);\n            this.device.on('radio.loaded', (e) => {\n                scaleRangeElement.setAttribute('max', radio.Playlist.Size - 1);\n            });\n            this.device.on('radio.next', (e) => {\n                scaleRangeElement.setAttribute('value', e.detail.position);\n            });\n            this.device.on('radio.previous', (e) => {\n                scaleRangeElement.setAttribute('value', e.detail.position);\n            });\n            this.device.on('radio.jump', (e) => {\n                scaleRangeElement.setAttribute('value', e.detail.position);\n            });\n        }\n        if (this.radio.wheelOver) {\n            const wheelOverElement = document.querySelector(this.radio.wheelOver);\n            wheelOverElement.addEventListener('wheel', (e) => {\n                if (this.device.ActiveSourceName !== 'radio') {\n                    return;\n                }\n                e.preventDefault();\n                if (e.deltaY > 0) {\n                    radio.previous();\n                }\n                else {\n                    radio.next();\n                }\n            }, false);\n        }\n        if (this.radio.info) {\n            let infoElement = document.querySelector(this.radio.info);\n            this.device.on('plugin-radio', (e) => {\n                infoElement.setAttribute('data-marquee', radio.Playlist.Entry.name + ': loading...');\n            });\n            this.device.on('radio.next', (e) => {\n                infoElement.setAttribute('data-marquee', radio.Playlist.Entry.name + ': loading...');\n            });\n            this.device.on('radio.previous', (e) => {\n                infoElement.setAttribute('data-marquee', radio.Playlist.Entry.name + ': loading...');\n            });\n            this.device.on('radio.jump', (e) => {\n                infoElement.setAttribute('data-marquee', radio.Playlist.Entry.name + ': loading...');\n            });\n            this.device.on('radio.stop', () => {\n                infoElement.setAttribute('data-marquee', 'Radio is offline');\n            });\n            this.device.on('plugout-radio', () => {\n                infoElement.setAttribute('data-marquee', 'Radio is offline');\n            });\n            this.device.on('radio.metadata', (e) => {\n                if (this.device.ActiveSourceName !== 'radio') {\n                    return;\n                }\n                infoElement.setAttribute('data-marquee', e.detail.title);\n            });\n        }\n        if (this.radio.playlist) {\n            let previousPosition = 0;\n            let playlistElement = document.querySelector(this.radio.playlist);\n            playlistElement.addEventListener('click', (event) => {\n                const path = event.path || (event.composedPath && event.composedPath());\n                for (let i = 0; i < path.length; i++) {\n                    if (path[i].hasAttribute && path[i].hasAttribute('data-playlist-index')) {\n                        if (this.device.ActiveSourceName !== 'radio') {\n                            this.device.plugIn('radio');\n                        }\n                        radio.playFromPosition(parseInt(path[i].getAttribute('data-playlist-index'), 10));\n                        break;\n                    }\n                    if (path[i].hasAttribute && path[i].hasAttribute('data-remove')) {\n                        const item = path[i].closest('[data-playlist-index]');\n                        const pos = parseInt(item.getAttribute('data-playlist-index'), 10);\n                        radio.Playlist.deleteEntry(pos);\n                        item.remove();\n                        break;\n                    }\n                    if (path[i].hasAttribute && path[i].hasAttribute('data-edit')) {\n                        const item = path[i].closest('[data-playlist-index]');\n                        const pos = parseInt(item.getAttribute('data-playlist-index'), 10);\n                        const entry = radio.Playlist.getEntryOf(pos);\n                        console.log({ entry });\n                        idInput.value = entry.id;\n                        nameInput.value = entry.name;\n                        urlInput.value = entry.src;\n                        if (entry.nowPlayingParser) {\n                            parserInput.value = entry.nowPlayingParser;\n                        }\n                        if (entry.nowPlayingParams) {\n                            paramsInput.value = Object.entries(entry.nowPlayingParams).map(entry => {\n                                return entry.join(': ');\n                            }).join('\\n');\n                        }\n                        idInput.setAttribute('readonly', 'readonly');\n                        form.style.setProperty('visibility', 'visible');\n                        form.dispatchEvent(new CustomEvent('dialog.open', {}));\n                        break;\n                    }\n                }\n            });\n            const container = document.createElement('TEMPLATE');\n            this.device.on('radio.loaded', (e) => {\n                playlistElement.innerHTML = '';\n                previousPosition = 0;\n                e.detail.playlist.forEach(({ name }, index) => {\n                    if (e.detail.playlist[index].deleted) {\n                        return;\n                    }\n                    container.innerHTML = this.radio.stationHTML;\n                    container.content.firstChild.setAttribute('data-playlist-index', index);\n                    const nameEl = container.content.firstChild.querySelector('[data-name]');\n                    nameEl ? (nameEl.textContent = name) : null;\n                    playlistElement.appendChild(container.content.firstChild);\n                });\n            });\n            if (this.classes && this.classes.activeItem) {\n                const activateItem = (event) => {\n                    const p = event.detail.position;\n                    if (previousPosition !== p) {\n                        try {\n                            playlistElement\n                                .querySelector(`[data-playlist-index=\"${previousPosition}\"]`)\n                                .classList.remove(this.classes.activeItem);\n                        }\n                        catch (_a) { }\n                    }\n                    previousPosition = p;\n                    try {\n                        const target = playlistElement.querySelector(`[data-playlist-index=\"${p}\"]`);\n                        target.classList.add(this.classes.activeItem);\n                        target.scrollIntoView({\n                            behavior: 'smooth',\n                            block: 'center'\n                        });\n                    }\n                    catch (_b) { }\n                    try {\n                        this.setUiStateItem('radioStationId', radio.Playlist.Entry.id);\n                    }\n                    catch (_c) { }\n                };\n                this.device.on('radio.play', activateItem);\n                this.device.on('radio.stationselected', activateItem);\n            }\n            if (this.radio.updateButton) {\n                document.querySelector(this.radio.updateButton)\n                    .addEventListener('click', () => {\n                    radio.Playlist.updateFromRemote();\n                });\n            }\n            if (form) {\n                //idInput readonly if editing\n                let saveButton = form.querySelector(`[name=\"station-save\"]`);\n                form.addEventListener('dialog.close', () => {\n                    idInput.value = '';\n                    nameInput.value = '';\n                    urlInput.value = '';\n                    parserInput.value = '';\n                    paramsInput.value = '';\n                    idInput.removeAttribute('readonly');\n                });\n                saveButton.addEventListener('click', () => {\n                    let entry = {\n                        id: idInput.value,\n                        name: nameInput.value,\n                        src: urlInput.value,\n                        nowPlayingParser: parserInput.value,\n                        nowPlayingParams: {},\n                        changedByUser: true,\n                    };\n                    paramsInput.value\n                        .trim().split(/\\r\\n|\\r|\\n/i)\n                        .forEach(line => {\n                        let result = line.split(':');\n                        let name = result.shift().trim();\n                        let value = result.join(':').trim();\n                        entry.nowPlayingParams[name] = value;\n                    });\n                    console.log(entry.nowPlayingParams);\n                    radio.Playlist.addEntry(entry)\n                        .then(() => {\n                        form.style.setProperty('visibility', 'hidden');\n                        form.dispatchEvent(new CustomEvent('dialog.close', {}));\n                    })\n                        .catch(e => console.error(e));\n                });\n            }\n        }\n    }\n    bindErrors() {\n        let corsError = `This may be a CORS error. If some stations don't play or don't show its info then you should install an extension \"CORS Unblock\" and activate it on this page.`;\n        let corsActions = {\n            'Go install': (e, toast) => {\n                toast.remove();\n                toast = null;\n                let url = 'https://chrome.google.com/webstore/detail/cors-unblock/lfhmikememgdcahcdlaciloancbhjino';\n                if (window.netscape) {\n                    url = 'https://addons.mozilla.org/ru/firefox/addon/cors-unblock';\n                }\n                window.open(url, '_blank').focus();\n            }\n        };\n        let httpError = `This may be a mixed content error. If some stations don't play or don't show its info then you should allow insecure content on this page.`;\n        if (window.netscape) {\n            httpError = `This may be a mixed content error. If some stations don't play or don't show its info then you should add this site in trusted pages.`;\n        }\n        if (!window.netscape && !window.chrome) {\n            delete corsActions['Go install'];\n        }\n        let mediaError = `${httpError} If insecure content is allowed already then this may be a CORS error. So to make the application work properly you should install an extension \"CORS Unblock\" and activate it on this page.`;\n        this.device.on('radio.trackerror', (e) => {\n            const radio = this.device.getSource('radio');\n            if (!radio.Playlist.Entry) {\n                return;\n            }\n            const err = e.detail.nativeEvent.target.error;\n            switch (err.code) {\n                case err.MEDIA_ERR_ABORTED:\n                    this.throwToast('error', 'Stream error', 'The audio downloading was aborted.');\n                    break;\n                case err.MEDIA_ERR_NETWORK:\n                    this.throwToast('error', 'Stream error', 'A network error while the audio downloading.');\n                    break;\n                case err.MEDIA_ERR_DECODE:\n                    this.throwToast('error', 'Stream error', 'Your browser does not support the stream type.');\n                    break;\n                case err.MEDIA_ERR_SRC_NOT_SUPPORTED:\n                    this.throwToast('error', 'Stream error', mediaError, corsActions);\n                    break;\n                default:\n                    this.throwToast('error', 'Stream error', 'An unknown error occured while the stream downloading');\n                    break;\n            }\n        });\n        this.device.on('radio.metadataerror', (e) => __awaiter(this, void 0, void 0, function* () {\n            const url = e.detail.url;\n            if (url.startsWith('http:')) {\n                this.throwToast('error', 'Data error', httpError);\n            }\n            else {\n                try {\n                    yield fetch(url, { 'mode': 'no-cors' });\n                    this.throwToast('error', 'Data error', corsError, corsActions);\n                }\n                catch (_a) {\n                    this.throwToast('error', 'Data error', 'An unknown error occured while the metadata downloading');\n                }\n            }\n            if (this.device.ActiveSourceName !== 'radio') {\n                return;\n            }\n            if (this.radio.info) {\n                let infoElement = document.querySelector(this.radio.info);\n                infoElement.setAttribute('data-marquee', e.detail.name + ': error while metadata fetching');\n            }\n        }));\n    }\n    potentiometer(selector, setFunc) {\n        if (selector) {\n            const element = document.querySelector(selector);\n            const uiStateKey = `potentiometer${selector}`;\n            element.addEventListener('input', () => {\n                setFunc(element.value);\n                this.setUiStateItem(uiStateKey, element.value);\n            }, false);\n            // load from storage\n            if (typeof this.uiState[uiStateKey] !== 'undefined') {\n                element.setAttribute('value', this.uiState[uiStateKey]);\n                setFunc(this.uiState[uiStateKey]);\n            }\n        }\n    }\n    key(selector, on, pressOn, unpressOn) {\n        if (selector) {\n            const key = document.querySelector(selector);\n            if (typeof on === 'function') {\n                key.addEventListener(\"click\", (e) => {\n                    e.preventDefault();\n                    on(e);\n                });\n            }\n            else {\n                for (let p in on) {\n                    key.addEventListener(p, (e) => {\n                        e.preventDefault();\n                        on[p](e);\n                    });\n                }\n            }\n            if (this.classes && this.classes.pressedKey) {\n                if (pressOn) {\n                    pressOn.forEach(event => {\n                        this.device.on(event, (e) => {\n                            key.classList.add(this.classes.pressedKey);\n                        });\n                    });\n                }\n                if (unpressOn) {\n                    unpressOn.forEach(event => {\n                        this.device.on(event, (e) => {\n                            key.classList.remove(this.classes.pressedKey);\n                        });\n                    });\n                }\n            }\n            return key;\n        }\n    }\n    throwToast(type, title, text, actions = {}) {\n        let toast = document.createElement('DIV');\n        toast.classList.add('toast');\n        toast.classList.add('toast-' + type);\n        let toastTitle = document.createElement('DIV');\n        toastTitle.classList.add('toast-title');\n        toastTitle.textContent = title;\n        let toastClose = document.createElement('A');\n        toastClose.classList.add('toast-close');\n        toastClose.textContent = '✕';\n        toastClose.setAttribute('href', '#');\n        toastClose.addEventListener('click', (e) => {\n            e.preventDefault();\n            toast.remove();\n            toast = null;\n        });\n        let toastText = document.createElement('DIV');\n        toastText.classList.add('toast-text');\n        toastText.textContent = text;\n        let toastActions = document.createElement('DIV');\n        toastActions.classList.add('toast-actions');\n        Object.keys(actions).forEach(actionName => {\n            let button = document.createElement('BUTTON');\n            button.classList.add('button');\n            button.textContent = actionName;\n            button.addEventListener('click', (e) => actions[actionName](e, toast));\n            toastActions.appendChild(button);\n        });\n        toastTitle.appendChild(toastClose);\n        toast.appendChild(toastTitle);\n        toast.appendChild(toastText);\n        toast.appendChild(toastActions);\n        document.querySelector('#toasts').appendChild(toast);\n        setTimeout(() => toast.classList.add('toast-visible'));\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Boombox);\n\n\n//# sourceURL=webpack:///./src/classes/Boombox.ts?");

/***/ }),

/***/ "./src/classes/Deck.ts":
/*!*****************************!*\
  !*** ./src/classes/Deck.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Deck)\n/* harmony export */ });\n/* harmony import */ var _types_DeckStates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/types/DeckStates */ \"./src/types/DeckStates.ts\");\n/* harmony import */ var _types_DeckMode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/types/DeckMode */ \"./src/types/DeckMode.ts\");\n/* harmony import */ var _abstracts_AudioSource__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/abstracts/AudioSource */ \"./src/abstracts/AudioSource.ts\");\n/* harmony import */ var _classes_DeckPlaylist__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/classes/DeckPlaylist */ \"./src/classes/DeckPlaylist.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\nclass Deck extends _abstracts_AudioSource__WEBPACK_IMPORTED_MODULE_2__[\"default\"] {\n    constructor(audioContext) {\n        super();\n        this.playbackMode = _types_DeckMode__WEBPACK_IMPORTED_MODULE_1__.DeckMode[\"default\"];\n        this.autoplay = false;\n        this.state = _types_DeckStates__WEBPACK_IMPORTED_MODULE_0__.DeckStates.stopped;\n        this.paused = false;\n        this.loadedIndex = -1;\n        this.codecs = [\n            {\n                name: '3GP',\n                type: 'audio/3gpp',\n                extensions: [\n                    '3gp',\n                    '3g2', //?\n                ],\n                available: false,\n            },\n            {\n                name: 'ADTS',\n                type: 'audio/aac',\n                extensions: [\n                    'aac',\n                ],\n                available: false,\n            },\n            {\n                name: 'FLAC',\n                type: 'audio/flac',\n                extensions: [\n                    'flac',\n                ],\n                available: false,\n            },\n            {\n                name: 'MPEG',\n                type: 'audio/mpeg',\n                extensions: [\n                    'mpg',\n                    'mpeg',\n                ],\n                available: false,\n            },\n            {\n                name: 'MP3',\n                type: 'audio/mp3',\n                extensions: [\n                    'mp3',\n                ],\n                available: false,\n            },\n            {\n                name: 'MP4',\n                type: 'audio/mp4',\n                extensions: [\n                    'mp4',\n                    'm4a',\n                ],\n                available: false,\n            },\n            {\n                name: 'OGG',\n                type: 'audio/ogg',\n                extensions: [\n                    'oga',\n                    'ogg',\n                ],\n                available: false,\n            },\n            {\n                name: 'WAV',\n                type: 'audio/wav',\n                extensions: [\n                    'wav',\n                ],\n                available: false,\n            },\n            {\n                name: 'WebM',\n                type: 'audio/webm',\n                extensions: [\n                    'webm',\n                ],\n                available: false,\n            },\n        ];\n        this.init(audioContext);\n    }\n    load(dirMode = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.emit('open');\n            return yield this.playlist.load(dirMode);\n        });\n    }\n    stop() {\n        // adding a callback on stop\n        this.audioElement.addEventListener('pause', () => __awaiter(this, void 0, void 0, function* () {\n            // console.log('PAUSE ONCE')\n            this.state = _types_DeckStates__WEBPACK_IMPORTED_MODULE_0__.DeckStates.stopped;\n            this.audioElement.currentTime = 0;\n            this.updateMediaPlaybackState();\n            this.emit('stop', { position: this.playlist.Position });\n        }), { once: true });\n        if (this.state === _types_DeckStates__WEBPACK_IMPORTED_MODULE_0__.DeckStates.paused) {\n            this.audioElement.dispatchEvent(new Event('pause'));\n        }\n        // stop track and run events chain\n        this.audioElement.pause();\n        return true;\n    }\n    pause() {\n        if (this.state === _types_DeckStates__WEBPACK_IMPORTED_MODULE_0__.DeckStates.playing) {\n            this.state = _types_DeckStates__WEBPACK_IMPORTED_MODULE_0__.DeckStates.busy;\n            this.audioElement.addEventListener('pause', () => {\n                this.state = _types_DeckStates__WEBPACK_IMPORTED_MODULE_0__.DeckStates.paused;\n                this.emit('pause-on', { position: this.playlist.Position });\n            }, { once: true });\n            this.audioElement.pause();\n            return true;\n        }\n        else if (this.state === _types_DeckStates__WEBPACK_IMPORTED_MODULE_0__.DeckStates.paused) {\n            this.state = _types_DeckStates__WEBPACK_IMPORTED_MODULE_0__.DeckStates.busy;\n            this.audioElement.addEventListener('playing', () => {\n                this.state = _types_DeckStates__WEBPACK_IMPORTED_MODULE_0__.DeckStates.playing;\n                this.emit('pause-off', { position: this.playlist.Position });\n            }, { once: true });\n            this.audioElement.play();\n            return true;\n        }\n        return false;\n    }\n    previous() {\n        if (this.state === _types_DeckStates__WEBPACK_IMPORTED_MODULE_0__.DeckStates.paused || this.playlist.Empty) {\n            return false;\n        }\n        //stop -> previous -> start\n        const oldPosition = this.playlist.Position;\n        if (!this.playlist.cursorToPreviousPlayable()) {\n            this.playlist.Position = oldPosition;\n        }\n        // scheduled stop and start\n        this.jumpFrom(oldPosition);\n        return true;\n    }\n    next() {\n        if (this.state === _types_DeckStates__WEBPACK_IMPORTED_MODULE_0__.DeckStates.paused || this.playlist.Empty) {\n            return false;\n        }\n        // stop -> next -> start\n        const oldPosition = this.playlist.Position;\n        if (!this.playlist.cursorToNextPlayable()) {\n            this.playlist.Position = oldPosition;\n        }\n        // scheduled stop and start\n        this.jumpFrom(oldPosition);\n        return true;\n    }\n    play() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.state !== _types_DeckStates__WEBPACK_IMPORTED_MODULE_0__.DeckStates.stopped) {\n                return false;\n            }\n            if (!this.playlist.isEntryPlayable(this.playlist.Position)) {\n                if (!this.playlist.cursorToNextPlayable()) {\n                    return false;\n                }\n            }\n            this.schedulePlayOnLoading({ position: this.playlist.Position });\n            this.loadTrack(this.playlist.Position);\n            return true;\n        });\n    }\n    nextDirectory() {\n        if (this.state === _types_DeckStates__WEBPACK_IMPORTED_MODULE_0__.DeckStates.paused || this.playlist.Empty) {\n            return false;\n        }\n        const oldPosition = this.playlist.Position;\n        if (!this.playlist.cursorToNextDirectory()) {\n            this.playlist.Position = oldPosition;\n        }\n        else if (!this.playlist.cursorToNextPlayable()) {\n            this.playlist.Position = oldPosition;\n        }\n        this.jumpFrom(oldPosition);\n        return true;\n    }\n    previousDirectory() {\n        if (this.state === _types_DeckStates__WEBPACK_IMPORTED_MODULE_0__.DeckStates.paused || this.playlist.Empty) {\n            return false;\n        }\n        const oldPosition = this.playlist.Position;\n        if (!this.playlist.cursorToPreviousDirectory()) {\n            this.playlist.Position = oldPosition;\n        }\n        else if (!this.playlist.cursorToNextPlayable()) {\n            this.playlist.Position = oldPosition;\n        }\n        this.jumpFrom(oldPosition);\n        return true;\n    }\n    playFromPosition(position) {\n        //stop -> next -> start\n        if (!this.playlist.isEntryPlayable(position)) {\n            return false;\n        }\n        const oldPosition = this.playlist.Position;\n        this.playlist.Position = position;\n        this.jumpFrom(oldPosition);\n        return true;\n    }\n    record() {\n        this.emit('record');\n    }\n    setPlaybackMode(playbackMode) {\n        this.playbackMode = playbackMode;\n    }\n    playlistMessage(message, data) {\n        switch (message) {\n            case 'loaded':\n                if (this.autoplay) {\n                    this.play();\n                }\n                else {\n                    this.loadTrack(this.playlist.Position);\n                }\n                this.emit('loaded', Object.assign({}, data));\n                break;\n            case 'trackchanged':\n                if (data.position === this.Playlist.Position) {\n                    this.updateMediaMetadata();\n                }\n                this.emit('trackchanged', Object.assign({}, data));\n                break;\n            case 'tracktimechanged':\n                this.emit('tracktimechanged', Object.assign({}, data));\n                break;\n            case 'notpicked':\n                this.emit('notpicked');\n                break;\n            case 'closedbyfallback':\n                this.emit('closedbyfallback');\n                break;\n            case 'cancel':\n                this.emit('cancel', Object.assign({}, data));\n                break;\n            default:\n                throw new Error('Unknown message from playlist to deck');\n        }\n    }\n    plugOut() {\n        this.stop();\n        super.plugOut();\n    }\n    // getters\n    get State() {\n        return this.state;\n    }\n    get Playlist() {\n        return this.playlist;\n    }\n    get Node() {\n        return this.node;\n    }\n    //?\n    get Context() {\n        return this.audioCtx;\n    }\n    get CurrentTime() {\n        return this.audioElement.currentTime;\n    }\n    get Track() {\n        return this.audioElement;\n    }\n    get SupportedCodecs() {\n        return this.codecs.filter(codec => codec.available);\n    }\n    get MediaMetadata() {\n        let e = this.playlist.Entry;\n        return new MediaMetadata({\n            artist: e.tags && e.tags.tags ? e.tags.tags.artist : '',\n            title: e.tags && e.tags.tags ? e.tags.tags.title : e.name,\n            album: e.tags && e.tags.tags ? e.tags.tags.album : e.path.join('/'),\n        });\n    }\n    // internal methods\n    init(audioContext) {\n        this.audioElement = new Audio();\n        this.checkCodecs();\n        this.playlist = new _classes_DeckPlaylist__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this.extensions, this);\n        this.audioCtx = audioContext;\n        this.node = this.audioCtx.createMediaElementSource(this.audioElement);\n        this.audioElement.addEventListener('playing', (e) => {\n            // console.log('playing', e, this.cursorPos);\n            console.log('PLAYING');\n        });\n        this.audioElement.addEventListener('pause', (e) => {\n            // console.log('pause', e, this.cursorPos);\n            this.updateMediaPositionState();\n            console.log('PAUSE');\n        });\n        // `ended` forwarding && running lpaylist logic\n        this.audioElement.addEventListener('ended', (e) => {\n            console.log('ended');\n            this.state = _types_DeckStates__WEBPACK_IMPORTED_MODULE_0__.DeckStates.stopped;\n            this.updateMediaPlaybackState();\n            if (this.playbackMode === _types_DeckMode__WEBPACK_IMPORTED_MODULE_1__.DeckMode.repeatTrack) {\n                this.emit('stop', {\n                    position: this.playlist.Position,\n                    nativeEvent: e,\n                    ended: true,\n                    playlistended: false,\n                    manual: false,\n                });\n                return this.play();\n            }\n            else if (this.playbackMode === _types_DeckMode__WEBPACK_IMPORTED_MODULE_1__.DeckMode.repeatDir) {\n                const previousTrackPath = this.playlist.Entry.path.join('/');\n                if (!this.playlist.cursorToNextPlayable() ||\n                    (previousTrackPath !== this.playlist.Entry.path.join('/'))) {\n                    if (this.playlist.cursorToFirstTrackOf(previousTrackPath)) {\n                        this.emit('stop', {\n                            position: this.playlist.Position,\n                            nativeEvent: e,\n                            ended: true,\n                            playlistended: false,\n                            manual: false,\n                        });\n                        return this.play();\n                    }\n                }\n            }\n            if (this.playlist.cursorToNextPlayable()) {\n                this.emit('stop', {\n                    position: this.playlist.Position,\n                    nativeEvent: e,\n                    ended: true,\n                    playlistended: false,\n                    manual: false,\n                });\n                return this.play();\n            }\n            this.playlist.resetPosition();\n            if (this.playbackMode === _types_DeckMode__WEBPACK_IMPORTED_MODULE_1__.DeckMode.repeatAll) {\n                this.play();\n            }\n            this.emit('stop', {\n                position: this.playlist.Position,\n                nativeEvent: e,\n                ended: true,\n                playlistended: true,\n                manual: false,\n            });\n        });\n        // `timeupdate` forwarding\n        this.audioElement.addEventListener('timeupdate', (e) => {\n            this.updateMediaPositionState();\n            this.emit('timeupdate', {\n                time: this.audioElement.currentTime,\n                position: this.playlist.Position,\n                nativeEvent: e,\n            });\n        });\n        // `loadstart` forwarding\n        this.audioElement.addEventListener('loadstart', (e) => {\n            console.log('LOADSTART');\n            this.emit('loadstart', { position: this.playlist.Position, nativeEvent: e });\n        });\n        // `progress` forwarding\n        this.audioElement.addEventListener('progress', (e) => {\n            console.log('PROGRESS');\n            this.emit('progress', { position: this.playlist.Position, nativeEvent: e });\n        });\n        // `loadend` forwarding\n        this.audioElement.addEventListener('loadeddata', (e) => {\n            console.log('LOADEDDATA');\n            this.emit('loadeddata', { position: this.playlist.Position, nativeEvent: e });\n        });\n        // `error` forwarding\n        this.audioElement.addEventListener('error', (e) => {\n            console.log('ERROR');\n            this.emit('trackerror', { position: this.playlist.Position, nativeEvent: e });\n        });\n        // `abort` forwarding\n        this.audioElement.addEventListener('abort', (e) => {\n            console.log('ABORT');\n            this.emit('trackabort', { position: this.playlist.Position, nativeEvent: e });\n        });\n    }\n    checkCodecs() {\n        let extensions = [];\n        this.codecs.forEach(codec => {\n            const result = this.audioElement.canPlayType(codec.type);\n            if (result === 'maybe' || result === 'probably') {\n                codec.available = true;\n                extensions = [...extensions, ...codec.extensions];\n            }\n        });\n        this.regExp = new RegExp('\\.(' + extensions.join('|') + ')$', 'i'); //remove\n        this.extensions = extensions.map(ext => `.${ext}`);\n    }\n    loadTrack(index) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.loadedIndex !== index) {\n                URL.revokeObjectURL(this.audioElement.src);\n                this.audioElement.removeAttribute('src');\n                this.audioElement.load();\n                this.audioElement.src = yield this.playlist.createObjectUrlOf(index);\n                this.loadedIndex = index;\n            }\n            else {\n                this.audioElement.dispatchEvent(new Event('loadeddata'));\n            }\n        });\n    }\n    jumpFrom(oldPosition) {\n        // adding a callback on stop\n        this.audioElement.addEventListener('pause', () => __awaiter(this, void 0, void 0, function* () {\n            // console.log('PAUSE ONCE')\n            this.loadTrack(this.playlist.Position);\n        }), { once: true });\n        // after all we start a new track\n        this.schedulePlayOnLoading({ position: this.playlist.Position, oldPosition });\n        if (this.audioElement.paused) {\n            this.audioElement.dispatchEvent(new Event('pause'));\n        }\n        else {\n            // stop track and run events chain\n            this.audioElement.pause();\n        }\n    }\n    schedulePlayOnLoading(playEventData) {\n        // adding an event on play\n        this.audioElement.addEventListener('playing', () => {\n            // console.log('PLAYING ONCE')\n            this.state = _types_DeckStates__WEBPACK_IMPORTED_MODULE_0__.DeckStates.playing;\n            this.updateMediaPlaybackState();\n            this.emit('play', playEventData);\n        }, { once: true });\n        // adding a callback on loading\n        this.audioElement.addEventListener('loadeddata', () => __awaiter(this, void 0, void 0, function* () {\n            // console.log('LOADEDDATA ONCE')\n            if (this.audioCtx.state === 'suspended') {\n                yield this.audioCtx.resume();\n            }\n            this.audioElement.play();\n        }), { once: true });\n    }\n    commonMediaAction(details) {\n        const skipTime = 5;\n        switch (details.action) {\n            case 'play':\n                if (this.state === _types_DeckStates__WEBPACK_IMPORTED_MODULE_0__.DeckStates.paused) {\n                    this.pause();\n                }\n                else if (this.state === _types_DeckStates__WEBPACK_IMPORTED_MODULE_0__.DeckStates.stopped) {\n                    this.play();\n                }\n                break;\n            case 'pause':\n                this.pause();\n                break;\n            case 'stop':\n                this.stop();\n                break;\n            case 'seekbackward':\n                this.Track.currentTime = Math.max(this.Track.currentTime - skipTime, 0);\n                break;\n            case 'seekforward':\n                this.Track.currentTime = Math.min(this.Track.currentTime + skipTime, this.Track.duration);\n                break;\n            case 'previoustrack':\n                this.previous();\n                break;\n            case 'nexttrack':\n                this.next();\n                break;\n            default:\n                console.log(`${details.action} - unsupported action`);\n        }\n    }\n}\n\n\n//# sourceURL=webpack:///./src/classes/Deck.ts?");

/***/ }),

/***/ "./src/classes/DeckPlaylist.ts":
/*!*************************************!*\
  !*** ./src/classes/DeckPlaylist.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ DeckPlaylist)\n/* harmony export */ });\n/* harmony import */ var _abstracts_EmitterEventTarget__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/abstracts/EmitterEventTarget */ \"./src/abstracts/EmitterEventTarget.ts\");\n/* harmony import */ var worker_loader_worker_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! worker-loader!@/worker.js */ \"./node_modules/worker-loader/dist/cjs.js!./src/worker.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __asyncValues = (undefined && undefined.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\n\n\nclass DeckPlaylist extends _abstracts_EmitterEventTarget__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor(extensions, source) {\n        super();\n        this.entries = [];\n        this.cursorPos = 0;\n        this.source = source;\n        this.extensions = extensions;\n        this.regExp = new RegExp('\\.(' + extensions.join('|') + ')$', 'i');\n        this.createLoadFallback();\n        this.playlistWorker = new worker_loader_worker_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n        this.playlistWorker.addEventListener('message', (e) => {\n            if (e.data.type === 'tags') {\n                this.setTagsTo(e.data.i, e.data.payload);\n            }\n        }, false);\n    }\n    setTagsTo(i, tags) {\n        this.entries[i].tags = tags;\n        this.source.playlistMessage('trackchanged', { position: i, tags });\n    }\n    reset() {\n        this.entries = [];\n        this.cursorPos = 0;\n    }\n    resetPosition() {\n        this.cursorPos = 0;\n    }\n    createObjectUrlOf(index) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof this.entries[index].instance.getFile === 'function') {\n                this.file = yield this.entries[index].instance.getFile();\n            }\n            else {\n                this.file = this.entries[index].instance;\n            }\n            return URL.createObjectURL(this.file);\n        });\n    }\n    get Entry() {\n        return this.entries[this.cursorPos] ? this.entries[this.cursorPos] : null;\n    }\n    get Position() {\n        return this.cursorPos;\n    }\n    set Position(position) {\n        this.cursorPos = position;\n    }\n    get Empty() {\n        return !this.entries.length;\n    }\n    load(dirMode = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.fallbackInputElement) {\n                let descriptor;\n                try {\n                    if (!dirMode) {\n                        descriptor = yield window.showOpenFilePicker({\n                            types: [{\n                                    description: 'Audio',\n                                    accept: {\n                                        'audio/*': this.extensions\n                                    }\n                                }],\n                            excludeAcceptAllOption: true,\n                            multiple: true\n                        });\n                        this.reset();\n                        for (let i = 0, l = descriptor.length; i < l; i++) {\n                            if (this.regExp.test(descriptor[i].name)) {\n                                this.entries.push({\n                                    name: descriptor[i].name,\n                                    level: 0,\n                                    instance: descriptor[i],\n                                    kind: 'file',\n                                    path: []\n                                });\n                            }\n                        }\n                        this.entries.sort((a, b) => {\n                            return (a.name < b.name) ? -1 : (a.name > b.name) ? 1 : 0;\n                        });\n                    }\n                    else {\n                        descriptor = yield window.showDirectoryPicker();\n                        let playlistItem = {\n                            name: descriptor.name,\n                            level: 0,\n                            instance: descriptor,\n                            kind: 'directory',\n                            path: [descriptor.name]\n                        };\n                        this.reset();\n                        this.entries.push(playlistItem);\n                        yield this.readDirectory(playlistItem);\n                    }\n                    if (!this.isEntryPlayable(this.cursorPos)) {\n                        if (!this.cursorToNextPlayable()) {\n                            throw new Error('No playable files selected.');\n                        }\n                    }\n                    this.source.playlistMessage('loaded', { playlist: this.entries });\n                    this.processEntries();\n                }\n                catch (error) {\n                    if (this.entries.length) {\n                        return this.source.playlistMessage('notpicked');\n                    }\n                    this.source.playlistMessage('cancel', { error });\n                }\n            }\n            else {\n                if (dirMode) {\n                    this.fallbackInputElement.setAttribute('mozdirectory', 'mozdirectory');\n                    this.fallbackInputElement.setAttribute('webkitdirectory', 'webkitdirectory');\n                    this.fallbackInputElement.setAttribute('directory', 'directory');\n                    this.fallbackInputElement.setAttribute('allowdirs', 'allowdirs');\n                    this.fallbackInputElement.removeAttribute('multiple');\n                }\n                else {\n                    this.fallbackInputElement.removeAttribute('mozdirectory');\n                    this.fallbackInputElement.removeAttribute('webkitdirectory');\n                    this.fallbackInputElement.removeAttribute('directory');\n                    this.fallbackInputElement.removeAttribute('allowdirs');\n                    this.fallbackInputElement.setAttribute('multiple', 'multiple');\n                }\n                this.fallbackInputElement.focus();\n                this.fallbackInputElement.click();\n                document.addEventListener('focus', () => {\n                    this.source.playlistMessage('closedbyfallback');\n                }, { once: true });\n            }\n        });\n    }\n    isEntryPlayable(index) {\n        return (index < this.entries.length) &&\n            (this.entries[index].kind !== 'directory') &&\n            (!this.entries[index].error);\n    }\n    isEntryExists(index) {\n        return !!this.entries[index];\n    }\n    isDirectory(index) {\n        return (index < this.entries.length) && (this.entries[index].kind === 'directory');\n    }\n    cursorToNextPlayable() {\n        do {\n            this.cursorPos++;\n        } while (this.isEntryExists(this.cursorPos) && !this.isEntryPlayable(this.cursorPos));\n        return this.isEntryExists(this.cursorPos);\n    }\n    cursorToPreviousPlayable() {\n        do {\n            this.cursorPos--;\n        } while (this.isEntryExists(this.cursorPos) && !this.isEntryPlayable(this.cursorPos));\n        return this.isEntryExists(this.cursorPos);\n    }\n    cursorToNextDirectory() {\n        do {\n            this.cursorPos++;\n        } while (this.isEntryExists(this.cursorPos) && !this.isDirectory(this.cursorPos));\n        return this.isEntryExists(this.cursorPos);\n    }\n    cursorToPreviousDirectory() {\n        let firstPassedBy = false;\n        do {\n            this.cursorPos--;\n            if (this.cursorPos < 0) {\n                break;\n            }\n            if (this.isDirectory(this.cursorPos)) {\n                // must bypass a first dir we meet, this is a current track dir\n                if (!firstPassedBy) {\n                    firstPassedBy = true;\n                    continue;\n                }\n                // checking whether a found dir contains tracks\n                if (this.isEntryPlayable(this.cursorPos + 1)) {\n                    break;\n                }\n                continue;\n            }\n            continue;\n        } while (1);\n        return this.isEntryExists(this.cursorPos);\n    }\n    cursorToFirstTrackOf(directory) {\n        do {\n            this.cursorPos--;\n        } while (this.isEntryExists(this.cursorPos) &&\n            (!this.isEntryPlayable(this.cursorPos) ||\n                directory === this.entries[this.cursorPos].path.join('/')));\n        this.cursorPos++;\n        return this.isEntryExists(this.cursorPos);\n    }\n    createLoadFallback() {\n        if (!window.showOpenFilePicker && !window.showDirectoryPicker) {\n            this.fallbackInputElement = document.createElement('INPUT');\n            this.fallbackInputElement.setAttribute('type', 'file');\n            const getFullPath = (file) => {\n                const i = file;\n                return i.webkitRelativePath || `${i.fullPath}/${i.name}`;\n            };\n            const getDirectory = (file) => {\n                const i = file;\n                return (i.fullPath || i.webkitRelativePath.slice(0, i.webkitRelativePath.lastIndexOf(\"/\")));\n            };\n            const sortByFullPath = (list) => {\n                list.sort((a, b) => {\n                    const apath = getFullPath(a);\n                    const bpath = getFullPath(b);\n                    return (apath < bpath) ?\n                        -1 : (apath > bpath) ?\n                        1 : 0;\n                });\n            };\n            this.fallbackInputElement.addEventListener(\"change\", (e) => {\n                this.reset();\n                let temp = [...e.target.files];\n                let lastDir = '';\n                sortByFullPath(temp);\n                temp.forEach(file => {\n                    if (this.regExp.test(file.name)) {\n                        let directory = getDirectory(file);\n                        if (directory != lastDir) {\n                            this.entries.push({\n                                name: directory,\n                                kind: 'directory',\n                                level: 0,\n                                path: [],\n                            });\n                            lastDir = directory;\n                        }\n                        this.entries.push({\n                            name: file.name,\n                            kind: 'file',\n                            level: 1,\n                            path: directory.split('/'),\n                            instance: file,\n                        });\n                    }\n                });\n                if (!this.isEntryPlayable(this.cursorPos)) {\n                    if (!this.cursorToNextPlayable()) {\n                        throw new Error('No playable files selected.');\n                    }\n                }\n                this.emit('loaded', { playlist: this.entries });\n                this.processEntries();\n            }, false);\n        }\n    }\n    readDirectory(item) {\n        var e_1, _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            let level = item.level + 1;\n            let temporaryArray = [];\n            try {\n                for (var _b = __asyncValues(item.instance.entries()), _c; _c = yield _b.next(), !_c.done;) {\n                    const [name, entry] = _c.value;\n                    if (entry.kind === 'directory' || this.regExp.test(name)) {\n                        let playlistItem = {\n                            name,\n                            level,\n                            kind: entry.kind,\n                            path: [...item.path],\n                            instance: entry,\n                        };\n                        if (entry.kind === 'directory') {\n                            playlistItem.path.push(name);\n                        }\n                        temporaryArray.push(playlistItem);\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            temporaryArray.sort((a, b) => {\n                if (a.kind !== b.kind) {\n                    return (a.kind < b.kind) ? -1 : (a.kind > b.kind) ? 1 : 0;\n                }\n                return (a.name < b.name) ? -1 : (a.name > b.name) ? 1 : 0;\n            });\n            let i = 0, l = temporaryArray.length;\n            while (i < l) {\n                this.entries.push(temporaryArray[i]);\n                if (temporaryArray[i].kind === 'directory') {\n                    let size = this.entries.length;\n                    yield this.readDirectory(temporaryArray[i]);\n                    if (size === this.entries.length) {\n                        // previously added directory is empty so remove it\n                        this.entries.pop();\n                    }\n                }\n                i++;\n            }\n        });\n    }\n    getAudioDuration(audio) {\n        return new Promise(function (resolve, reject) {\n            const load = (e) => {\n                audio.removeEventListener('loadedmetadata', load);\n                audio.removeEventListener('error', error);\n                resolve(audio.duration);\n            };\n            const error = () => {\n                audio.removeEventListener('loadedmetadata', load);\n                audio.removeEventListener('error', error);\n                reject();\n            };\n            audio.addEventListener('loadedmetadata', load);\n            audio.addEventListener('error', error);\n        });\n    }\n    processEntries() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.playlistWorker.postMessage({\n                type: 'playlist',\n                payload: {\n                    playlist: this.entries,\n                },\n            });\n            let audio = new Audio();\n            for (let i = 0; i < this.entries.length; i++) {\n                let item = this.entries[i];\n                if (item.kind !== 'directory') {\n                    let entry = item.instance;\n                    try {\n                        if (typeof entry.getFile === 'function') {\n                            audio.src = URL.createObjectURL(yield entry.getFile());\n                        }\n                        else {\n                            audio.src = URL.createObjectURL(entry);\n                        }\n                        const duration = yield this.getAudioDuration(audio);\n                        this.source.playlistMessage('tracktimechanged', { position: i, duration });\n                    }\n                    catch (e) {\n                        item.error = true;\n                        this.source.playlistMessage('tracktimechanged', { position: i, duration: 0 });\n                    }\n                    if (audio.src) {\n                        URL.revokeObjectURL(audio.src);\n                    }\n                }\n            }\n            audio = null;\n        });\n    }\n}\n\n\n//# sourceURL=webpack:///./src/classes/DeckPlaylist.ts?");

/***/ }),

/***/ "./src/classes/Device.ts":
/*!*******************************!*\
  !*** ./src/classes/Device.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Device)\n/* harmony export */ });\n/* harmony import */ var _abstracts_EmitterEventTarget__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/abstracts/EmitterEventTarget */ \"./src/abstracts/EmitterEventTarget.ts\");\n\n/**\n * Device abstraction implements easy sources control and single event bus\n */\nclass Device extends _abstracts_EmitterEventTarget__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor(sources, components, defaultSourseName) {\n        super();\n        this.sources = new Map(sources);\n        this.components = new Map(components);\n        this.components.forEach((component, name) => {\n            if (!this.in) {\n                this.in = component.InNode;\n            }\n            if (this.out) {\n                this.out.connect(component.InNode);\n            }\n            this.out = component.OutNode;\n        });\n        this.plugIn(defaultSourseName);\n    }\n    /**\n     * Plug in a source by name\n     * @param newSourceName\n     */\n    plugIn(newSourceName) {\n        if (!this.sources.has(newSourceName)) {\n            throw new Error(`No source named \"${newSourceName}\"`);\n        }\n        let oldSourceName = this.activeSourceName;\n        let newSource = this.sources.get(newSourceName);\n        if (this.sources.has(oldSourceName)) {\n            let oldSource = this.sources.get(oldSourceName);\n            oldSource.plugOut();\n            oldSource.Node.disconnect(this.in);\n            this.out.disconnect(oldSource.Node.context.destination);\n            this.emit('plugout-' + oldSourceName, {\n                oldSourceName,\n                newSourceName,\n            });\n        }\n        newSource.plugIn();\n        this.activeSourceName = newSourceName;\n        newSource.Node.connect(this.in);\n        this.out.connect(newSource.Node.context.destination);\n        this.emit('plugin-' + newSourceName, {\n            oldSourceName,\n            newSourceName,\n        });\n    }\n    /**\n     * Plug out current source\n     */\n    plugOut() {\n        let oldSource = this.sources.get(this.activeSourceName);\n        if (oldSource) {\n            oldSource.plugOut();\n        }\n        let oldSourceName = this.activeSourceName;\n        let newSourceName = '';\n        this.activeSourceName = newSourceName;\n        this.emit('plugout-' + oldSourceName, {\n            oldSourceName,\n            newSourceName,\n        });\n    }\n    /**\n     * `addEventListener` alias. Can listen source's and device's events\n     * @param eventName SourceName.EventName or just EventName if listener added to device\n     * @param callback\n     * @param options\n     * @returns void\n     */\n    on(eventName, callback, options) {\n        const [part1, event] = eventName.split('.');\n        if (!event) { //part1 is event name\n            return this.addEventListener(part1, callback, options);\n        }\n        //part1 is source name\n        if (!this.sources.has(part1)) {\n            throw new Error(`No source named \"${part1}\"`);\n        }\n        this.sources.get(part1).addEventListener(event, callback, options);\n    }\n    /**\n     * Get source by name\n     * @param name\n     * @returns\n     */\n    getSource(name) {\n        if (!this.sources.has(name)) {\n            throw new Error(`No source named \"${name}\"`);\n        }\n        return this.sources.get(name);\n    }\n    /**\n     * Get component by name\n     * @param name\n     * @returns\n     */\n    getComponent(name) {\n        if (!this.components.has(name)) {\n            throw new Error(`No component named \"${name}\"`);\n        }\n        return this.components.get(name);\n    }\n    /**\n     * Current plugged in AudioSource instance\n     *\n     * @readonly\n     * @type {(AudioSource | false)}\n     * @memberof Device\n     */\n    get activeSource() {\n        if (!this.activeSourceName) {\n            false;\n        }\n        return this.sources.get(this.activeSourceName);\n    }\n    get ActiveSourceName() {\n        return this.activeSourceName;\n    }\n}\n\n\n//# sourceURL=webpack:///./src/classes/Device.ts?");

/***/ }),

/***/ "./src/classes/Equalizer.ts":
/*!**********************************!*\
  !*** ./src/classes/Equalizer.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Equalizer)\n/* harmony export */ });\nclass Equalizer extends EventTarget {\n    constructor(context, options) {\n        super();\n        this.context = context;\n        this.options = options;\n        this.nodes = [];\n        this.init(context);\n    }\n    init(context) {\n        this.options.bands.forEach((band, index) => {\n            const filter = context.createBiquadFilter();\n            filter.frequency.value = band.frequency;\n            filter.Q.value = band.q;\n            filter.type = band.type;\n            filter.gain.value = 0;\n            this.nodes.push(filter);\n        });\n        this.nodes.forEach((node, i) => {\n            if (i) {\n                this.nodes[(i - 1)].connect(node);\n            }\n        });\n    }\n    gain(i, value) {\n        this.nodes[i].gain.value = value;\n    }\n    get Nodes() {\n        return this.nodes;\n    }\n    get InNode() {\n        return this.nodes[0];\n    }\n    get OutNode() {\n        return this.nodes[(this.nodes.length - 1)];\n    }\n}\n\n\n//# sourceURL=webpack:///./src/classes/Equalizer.ts?");

/***/ }),

/***/ "./src/classes/Receiver.ts":
/*!*********************************!*\
  !*** ./src/classes/Receiver.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Receiver)\n/* harmony export */ });\n/* harmony import */ var _types_ReceiverStates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/types/ReceiverStates */ \"./src/types/ReceiverStates.ts\");\n/* harmony import */ var _abstracts_AudioSource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/abstracts/AudioSource */ \"./src/abstracts/AudioSource.ts\");\n/* harmony import */ var _classes_ReceiverPlaylist__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/classes/ReceiverPlaylist */ \"./src/classes/ReceiverPlaylist.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\nclass Receiver extends _abstracts_AudioSource__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n    constructor(audioContext) {\n        super();\n        this.state = _types_ReceiverStates__WEBPACK_IMPORTED_MODULE_0__.ReceiverStates.stopped;\n        this.init(audioContext);\n    }\n    get Node() {\n        return this.node;\n    }\n    get MediaMetadata() {\n        return new MediaMetadata({\n            title: this.playlist.Entry.title,\n            artist: '',\n            album: '',\n        });\n    }\n    get Playlist() {\n        return this.playlist;\n    }\n    playlistMessage(message, data) {\n        switch (message) {\n            case 'loaded':\n                this.emit('loaded', Object.assign({}, data));\n                break;\n            case 'stop':\n                this.stop();\n                break;\n            case 'metadata':\n                this.emit('metadata', Object.assign({}, data));\n                this.updateMediaMetadata();\n                break;\n            case 'metadataerror':\n                this.emit('metadataerror', data);\n                break;\n            case 'stationselected':\n                this.emit('stationselected', data);\n                break;\n            default:\n                throw new Error('Unknown message from stationlist to receiver');\n        }\n    }\n    play() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.state !== _types_ReceiverStates__WEBPACK_IMPORTED_MODULE_0__.ReceiverStates.stopped) {\n                return false;\n            }\n            if (this.audioCtx.state === 'suspended') {\n                yield this.audioCtx.resume();\n            }\n            this.schedulePlayOnLoading({ position: this.playlist.Position });\n            this.loadTrack(this.playlist.Position);\n            return true;\n        });\n    }\n    stop() {\n        // adding a callback on stop\n        this.audioElement.addEventListener('pause', () => __awaiter(this, void 0, void 0, function* () {\n            // console.log('PAUSE ONCE')\n            this.state = _types_ReceiverStates__WEBPACK_IMPORTED_MODULE_0__.ReceiverStates.stopped;\n            this.audioElement.removeAttribute('src');\n            this.audioElement.load();\n            this.updateMediaPlaybackState();\n            this.emit('stop', { position: this.playlist.Position });\n        }), { once: true });\n        // stop track and run events chain\n        this.audioElement.pause();\n        return true;\n    }\n    previous() {\n        if (this.state === _types_ReceiverStates__WEBPACK_IMPORTED_MODULE_0__.ReceiverStates.stopped) {\n            return false;\n        }\n        //stop -> previous -> start\n        const oldPosition = this.playlist.Position;\n        if (!this.playlist.cursorToPreviousPlayable()) {\n            this.playlist.Position = oldPosition;\n        }\n        this.emit('previous', { position: this.playlist.Position });\n        // scheduled stop and start\n        this.jumpFrom(oldPosition);\n        return true;\n    }\n    next() {\n        if (this.state === _types_ReceiverStates__WEBPACK_IMPORTED_MODULE_0__.ReceiverStates.stopped) {\n            return false;\n        }\n        // stop -> next -> start\n        const oldPosition = this.playlist.Position;\n        if (!this.playlist.cursorToNextPlayable()) {\n            this.playlist.Position = oldPosition;\n        }\n        this.emit('next', { position: this.playlist.Position });\n        // scheduled stop and start\n        this.jumpFrom(oldPosition);\n        return true;\n    }\n    playFromPosition(position) {\n        //stop -> next -> start\n        if (!this.playlist.isEntryPlayable(position)) {\n            return false;\n        }\n        const oldPosition = this.playlist.Position;\n        this.playlist.Position = position;\n        this.emit('jump', { position: this.playlist.Position, oldPosition });\n        this.jumpFrom(oldPosition);\n        return true;\n    }\n    plugIn() {\n        this.play();\n        super.plugIn();\n        this.pluggedIn = true;\n    }\n    plugOut() {\n        this.stop();\n        super.plugOut();\n        this.pluggedIn = false;\n    }\n    init(audioContext) {\n        this.audioCtx = audioContext;\n        this.audioElement = new Audio();\n        this.audioElement.crossOrigin = \"anonymous\";\n        this.node = this.audioCtx.createMediaElementSource(this.audioElement);\n        this.playlist = new _classes_ReceiverPlaylist__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this);\n        this.audioElement.addEventListener('playing', (e) => {\n            this.updateMediaPlaybackState(); //?\n            //\n        });\n        this.audioElement.addEventListener('pause', (e) => {\n            this.updateMediaPositionState(); //?\n            // console.log('pause', e, this.cursorPos);\n            // console.log('RADIO PAUSE')\n        });\n        // `ended` forwarding && running lpaylist logic\n        this.audioElement.addEventListener('ended', (e) => {\n            this.updateMediaPlaybackState(); //?\n            // console.log('RADIO ENDED')\n        });\n        // `timeupdate` forwarding\n        this.audioElement.addEventListener('timeupdate', (e) => {\n            this.updateMediaPositionState();\n            this.emit('timeupdate', {\n                time: this.audioElement.currentTime,\n                position: this.playlist.Position,\n                nativeEvent: e,\n            });\n            if (this.audioElement.currentTime > 0) {\n                this.playlist.refreshMetadata();\n            }\n        });\n        // `loadstart` forwarding\n        this.audioElement.addEventListener('loadstart', (e) => __awaiter(this, void 0, void 0, function* () {\n            this.emit('loadstart', { position: this.playlist.Position, nativeEvent: e });\n            this.Playlist.refreshMetadata(true);\n        }));\n        // `progress` forwarding\n        this.audioElement.addEventListener('progress', (e) => {\n            // console.log({meta: (this.audioElement as any).captureStream()})\n            this.emit('progress', { position: this.playlist.Position, nativeEvent: e });\n        });\n        // `loadend` forwarding\n        this.audioElement.addEventListener('loadeddata', (e) => {\n            // console.log('RADIO LOADEDDATA')\n            this.emit('loadeddata', { position: this.playlist.Position, nativeEvent: e });\n        });\n        // `error` forwarding\n        this.audioElement.addEventListener('error', (e) => {\n            this.emit('trackerror', { position: this.playlist.Position, nativeEvent: e });\n        });\n        // `abort` forwarding\n        this.audioElement.addEventListener('abort', (e) => {\n            console.log('RADIO ABORT');\n            this.emit('trackabort', { position: this.playlist.Position, nativeEvent: e });\n        });\n        //this may be in other function\n        // this.emit('loaded', {playlist: this.playlist});\n    }\n    schedulePlayOnLoading(playEventData) {\n        // adding an event on play\n        this.audioElement.addEventListener('playing', () => {\n            // console.log('PLAYING ONCE')\n            this.state = _types_ReceiverStates__WEBPACK_IMPORTED_MODULE_0__.ReceiverStates.playing;\n            this.emit('play', playEventData);\n        }, { once: true });\n        // adding a callback on loading\n        this.audioElement.addEventListener('loadeddata', () => {\n            // console.log('LOADEDDATA ONCE')\n            this.audioElement.play();\n        }, { once: true });\n    }\n    loadTrack(index) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // if (this.loadedIndex !== index) {\n            this.audioElement.removeAttribute('src');\n            this.audioElement.load();\n            //this.playlist[index]\n            this.audioElement.src = this.playlist.getSrcOf(index);\n            // this.loadedIndex = index;\n            // } else {\n            // this.audioElement.dispatchEvent(new Event('loadeddata'));\n            // }\n        });\n    }\n    jumpFrom(oldPosition) {\n        // adding a callback on stop\n        this.audioElement.addEventListener('pause', () => __awaiter(this, void 0, void 0, function* () {\n            // console.log('PAUSE ONCE')\n            this.loadTrack(this.playlist.Position);\n        }), { once: true });\n        // after all we start a new track\n        this.schedulePlayOnLoading({ position: this.playlist.Position, oldPosition });\n        if (this.audioElement.paused) {\n            this.audioElement.dispatchEvent(new Event('pause'));\n        }\n        else {\n            // stop track and run events chain\n            this.audioElement.pause();\n        }\n    }\n    commonMediaAction(details) {\n        console.log(`${details.action} called`);\n        switch (details.action) {\n            case 'play':\n                if (this.state === _types_ReceiverStates__WEBPACK_IMPORTED_MODULE_0__.ReceiverStates.stopped) {\n                    this.plugOut();\n                }\n                else if (this.state === _types_ReceiverStates__WEBPACK_IMPORTED_MODULE_0__.ReceiverStates.playing) {\n                    this.play();\n                }\n                break;\n            case 'pause':\n                this.plugOut();\n                break;\n            case 'stop':\n                this.stop();\n                break;\n            case 'previoustrack':\n                this.previous();\n                break;\n            case 'nexttrack':\n                this.next();\n                break;\n            default:\n                console.log(`${details.action} - unsupported action`);\n        }\n    }\n}\n\n\n//# sourceURL=webpack:///./src/classes/Receiver.ts?");

/***/ }),

/***/ "./src/classes/ReceiverPlaylist.ts":
/*!*****************************************!*\
  !*** ./src/classes/ReceiverPlaylist.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ReceiverPlaylist)\n/* harmony export */ });\n/* harmony import */ var _abstracts_EmitterEventTarget__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/abstracts/EmitterEventTarget */ \"./src/abstracts/EmitterEventTarget.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\nconst DATABASE = 'boombox';\nconst VERSION = 1;\nconst STORAGE = 'stations';\nclass ReceiverPlaylist extends _abstracts_EmitterEventTarget__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor(source) {\n        super();\n        this.entries = [];\n        this.cursorPos = 0;\n        this.fetchMetadataInterval = 10;\n        this.lastFetchTime = 0;\n        this.noFetchMetadata = false;\n        this.source = source;\n        this.initDB();\n    }\n    initDB() {\n        let openRequest = indexedDB.open(DATABASE, VERSION);\n        let upgrade = false;\n        openRequest.addEventListener('upgradeneeded', () => {\n            console.log('upgradeneeded');\n            this.db = openRequest.result;\n            switch (this.db.version) {\n                case 1:\n                    this.db.createObjectStore(STORAGE, { keyPath: 'id' });\n                    upgrade = true;\n                    break;\n                // case 1: \n                //   break;\n            }\n        });\n        openRequest.addEventListener('error', function () {\n            console.error(\"Error\", openRequest.error);\n        });\n        openRequest.addEventListener('success', () => {\n            if (!this.db) {\n                this.db = openRequest.result;\n            }\n            this.db.addEventListener('versionchange', () => {\n                this.db.close();\n                console.error(\"Error\", \"База данных устарела, пожалуста, перезагрузите страницу.\");\n            });\n            if (!upgrade) {\n                this.loadFromDB();\n            }\n            else {\n                this.updateFromRemote();\n            }\n            this.db.addEventListener('complete', () => {\n                console.log('DB transaction complete');\n            });\n            this.db.addEventListener('error', () => {\n                console.log('DB transaction error');\n            });\n            this.db.addEventListener('abort', () => {\n                console.log('DB transaction abort');\n            });\n        });\n    }\n    get Entry() {\n        return this.entries[this.cursorPos] ? this.entries[this.cursorPos] : null;\n    }\n    get Size() {\n        return this.entries.length;\n    }\n    get Position() {\n        return this.cursorPos;\n    }\n    set Position(position) {\n        this.cursorPos = position;\n        this.source.playlistMessage('stationselected', { position });\n    }\n    updateFromRemote() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.source.playlistMessage('stop');\n            try {\n                const response = yield fetch('/data/stations.json');\n                const data = yield response.json();\n                let transaction = this.db.transaction([STORAGE], \"readwrite\");\n                let store = transaction.objectStore(STORAGE);\n                for (let i = 0, l = data.length; i < l; i++) {\n                    let entryIdx = this.entries.findIndex(entry => entry.id === data[i].id);\n                    let existed = this.entries[entryIdx];\n                    if (existed && existed.changedByUser) {\n                        continue;\n                    }\n                    let request;\n                    if (existed) {\n                        if (existed.deleted) {\n                            data[i].deleted = true;\n                        }\n                        request = store.put(data[i]);\n                    }\n                    else if (data[i].deleted) {\n                        continue;\n                    }\n                    else {\n                        request = store.add(data[i]);\n                    }\n                    request.addEventListener('success', () => {\n                        console.log('stored', request.result);\n                    });\n                    request.addEventListener('error', () => {\n                        console.error(\"Error\", request.error);\n                    });\n                }\n                transaction.addEventListener('complete', () => {\n                    console.log(\"All records processed\");\n                    this.loadFromDB();\n                });\n            }\n            catch (e) {\n                console.error(e);\n            }\n        });\n    }\n    addEntry(entry) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                this.source.playlistMessage('stop');\n                let transaction = this.db.transaction([STORAGE], \"readwrite\");\n                let store = transaction.objectStore(STORAGE);\n                let entryIdx = this.entries.findIndex(item => entry.id === item.id);\n                let request;\n                if (entryIdx < 0) {\n                    request = store.add(entry);\n                }\n                else {\n                    request = store.put(entry);\n                }\n                transaction.addEventListener('error', () => {\n                    reject(request.error);\n                });\n                transaction.addEventListener('complete', () => {\n                    resolve();\n                    this.loadFromDB();\n                });\n            });\n        });\n    }\n    deleteEntry(position) {\n        if (!this.isEntryExists(position) || !this.isEntryPlayable(position)) {\n            return;\n        }\n        this.entries[position].deleted = true;\n        let transaction = this.db.transaction([STORAGE], \"readwrite\");\n        let store = transaction.objectStore(STORAGE);\n        let request = store.put(this.entries[position]);\n        request.addEventListener('success', () => {\n            console.log('deleted', request.result);\n        });\n        request.addEventListener('error', () => {\n            console.error(\"Error\", request.error);\n        });\n    }\n    getPositionById(id) {\n        let pos = this.entries.findIndex((station) => station.id === id);\n        if (!Number.isInteger(pos)) {\n            throw new Error(`Wrong position number`);\n        }\n        return pos;\n    }\n    cursorToNextPlayable() {\n        do {\n            this.cursorPos++;\n        } while (this.isEntryExists(this.cursorPos) && !this.isEntryPlayable(this.cursorPos));\n        return this.isEntryExists(this.cursorPos);\n    }\n    cursorToPreviousPlayable() {\n        do {\n            this.cursorPos--;\n        } while (this.isEntryExists(this.cursorPos) && !this.isEntryPlayable(this.cursorPos));\n        return this.isEntryExists(this.cursorPos);\n    }\n    isEntryPlayable(position) {\n        return (position < this.entries.length) &&\n            !!this.entries[position].src &&\n            !this.entries[position].deleted;\n    }\n    isEntryExists(position) {\n        return !!this.entries[position];\n    }\n    getSrcOf(position) {\n        if (this.isEntryPlayable(position)) {\n            return this.entries[position].src;\n        }\n        return '';\n    }\n    getEntryOf(position) {\n        return this.entries[position];\n    }\n    refreshMetadata(forced = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (forced) {\n                this.lastFetchTime = 0;\n                this.noFetchMetadata = false;\n            }\n            if (this.noFetchMetadata) {\n                return;\n            }\n            if (!this.Entry) {\n                return;\n            }\n            if (!this.Entry.nowPlayingParser) {\n                this.source.playlistMessage('metadata', { title: `${this.Entry.name}: the programm title is not provided` });\n                return;\n            }\n            let refresh = yield this[this.Entry.nowPlayingParser]();\n            if (refresh) {\n                this.source.playlistMessage('metadata', { title: this.Entry.title });\n            }\n        });\n    }\n    loadFromDB() {\n        let transaction = this.db.transaction([STORAGE], 'readonly');\n        let getAll = transaction.objectStore(STORAGE).getAll();\n        getAll.addEventListener('success', () => {\n            getAll.result.sort((a, b) => {\n                return (a.name < b.name) ? -1 : (a.name > b.name) ? 1 : 0;\n            });\n            this.entries = getAll.result;\n            this.source.playlistMessage('loaded', { playlist: this.entries });\n        });\n    }\n    getNowPlayingData(urlGetter, resultParser) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let now = Math.ceil(performance.now() / 1000);\n            if (this.lastFetchTime && ((this.lastFetchTime + this.fetchMetadataInterval) > now)) {\n                return false;\n            }\n            this.lastFetchTime = now;\n            let response;\n            const url = yield urlGetter();\n            try {\n                const initPos = this.Position;\n                response = yield fetch(url);\n                this.Entry.title = yield resultParser(response);\n                return initPos === this.Position;\n            }\n            catch (error) {\n                this.noFetchMetadata = true;\n                this.source.playlistMessage('metadataerror', { url, error, name: this.Entry.name });\n            }\n        });\n    }\n    shoutcastTagsParser() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.getNowPlayingData(() => __awaiter(this, void 0, void 0, function* () {\n                let url = '';\n                if (this.Entry.nowPlayingParams && this.Entry.nowPlayingParams.url) {\n                    url = this.Entry.nowPlayingParams.url;\n                }\n                else {\n                    url = this.Entry.src.split('?')[0] + '/7.html';\n                }\n                return url;\n            }), (response) => __awaiter(this, void 0, void 0, function* () {\n                try {\n                    const content = yield response.text();\n                    let tmp = document.createElement(\"div\");\n                    tmp.innerHTML = content;\n                    let parts = tmp.textContent.split(',');\n                    let data = {\n                        listeners: parts.shift(),\n                        status: parts.shift(),\n                        peak: parts.shift(),\n                        max: parts.shift(),\n                        unique: parts.shift(),\n                        bitrate: parts.shift(),\n                        title: parts.join(',')\n                    };\n                    return `${this.Entry.name}: ${data.title}, ${data.bitrate}kb/s`;\n                }\n                catch (_a) {\n                    return `${this.Entry.name}: Title loading error`;\n                }\n            }));\n        });\n    }\n    jsonTagsParser() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.getNowPlayingData(() => __awaiter(this, void 0, void 0, function* () {\n                return this.Entry.nowPlayingParams.url;\n            }), (response) => __awaiter(this, void 0, void 0, function* () {\n                try {\n                    const content = yield response.json();\n                    let data = {};\n                    if (this.Entry.nowPlayingParams.bitrate) {\n                        data.bitrate = eval('content' + this.Entry.nowPlayingParams.bitrate);\n                    }\n                    if (this.Entry.nowPlayingParams.title) {\n                        data.title = eval('content' + this.Entry.nowPlayingParams.title);\n                    }\n                    if (this.Entry.nowPlayingParams.artist) {\n                        data.artist = eval('content' + this.Entry.nowPlayingParams.artist);\n                    }\n                    let title = `${this.Entry.name}`;\n                    title += data.artist ? `: ${data.artist}` : '';\n                    title += data.title ? ` - ${data.title}` : '';\n                    title += data.bitrate ? `, ${data.bitrate}kb/s` : '';\n                    return title;\n                }\n                catch (_a) {\n                    return `${this.Entry.name}: Title loading error`;\n                }\n            }));\n        });\n    }\n    icecast224TagsParser() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.getNowPlayingData(() => __awaiter(this, void 0, void 0, function* () {\n                let url = '';\n                if (this.Entry.nowPlayingParams && this.Entry.nowPlayingParams.url) {\n                    url = this.Entry.nowPlayingParams.url;\n                }\n                else {\n                    url = this.Entry.src.split('/', 3).join('/') + '/status-json.xsl';\n                }\n                return url;\n            }), (response) => __awaiter(this, void 0, void 0, function* () {\n                try {\n                    const data = yield response.json();\n                    let title = `${this.Entry.name}`;\n                    title += data.icestats.source[1].artist ? `: ${data.icestats.source[1].artist}` : '';\n                    title += data.icestats.source[1].title ? ` - ${data.icestats.source[1].title}` : '';\n                    title += data.icestats.source[2].bitrate ? `, ${data.icestats.source[2].bitrate}kb/s` : '';\n                    return title;\n                }\n                catch (_a) {\n                    return `${this.Entry.name}: Title loading error`;\n                }\n            }));\n        });\n    }\n}\n\n\n//# sourceURL=webpack:///./src/classes/ReceiverPlaylist.ts?");

/***/ }),

/***/ "./src/classes/UiSounds.ts":
/*!*********************************!*\
  !*** ./src/classes/UiSounds.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ UiSounds)\n/* harmony export */ });\nclass UiSounds {\n    static create(name, url, loop = false) {\n        const element = new Audio(url);\n        element.loop = loop;\n        this.audioElements.set(name, element);\n    }\n    static play(name) {\n        if (!this.audioElements.has(name)) {\n            throw new Error(`Sound ${name} not defined`);\n        }\n        const sound = this.audioElements.get(name);\n        if (sound.paused) {\n            sound.play();\n        }\n    }\n    static stop(name) {\n        if (!this.audioElements.has(name)) {\n            throw new Error(`Sound ${name} not defined`);\n        }\n        const sound = this.audioElements.get(name);\n        if (!sound.paused) {\n            sound.currentTime = 0;\n            sound.pause();\n        }\n    }\n}\nUiSounds.audioElements = new Map();\n\n\n//# sourceURL=webpack:///./src/classes/UiSounds.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _scss_style_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scss/style.scss */ \"./src/scss/style.scss\");\n/* harmony import */ var _elements_Slider_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./elements/Slider.js */ \"./src/elements/Slider.js\");\n/* harmony import */ var _elements_Slider_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_elements_Slider_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _classes_Boombox__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./classes/Boombox */ \"./src/classes/Boombox.ts\");\n\n\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n    new _classes_Boombox__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({\n        keys: {\n            loadStop: '#button-stop',\n            play: '#button-play',\n            pause: '#button-pause',\n            previous: '#button-rewind',\n            next: '#button-forward',\n            autostart: '#button-autostart',\n            repeatTrackMode: '#button-repeat-track',\n            repeatDirMode: '#button-repeat-dir',\n            repeatAllMode: '#button-repeat-all',\n            nextDirectory: '#button-next-dir',\n            previousDirectory: '#button-prev-dir',\n        },\n        equalizer: [\n            {\n                selector: '#equalizer-1',\n                frequency: 60,\n                q: 1,\n                type: \"lowshelf\",\n            },\n            {\n                selector: '#equalizer-2',\n                frequency: 120,\n                q: 1,\n                type: \"peaking\",\n            },\n            {\n                selector: '#equalizer-3',\n                frequency: 250,\n                q: 1,\n                type: \"peaking\",\n            },\n            {\n                selector: '#equalizer-4',\n                frequency: 1000,\n                q: 1,\n                type: \"peaking\",\n            },\n            {\n                selector: '#equalizer-5',\n                frequency: 3000,\n                q: 1,\n                type: \"peaking\",\n            },\n            {\n                selector: '#equalizer-6',\n                frequency: 10000,\n                q: 1,\n                type: \"peaking\",\n            },\n            {\n                selector: '#equalizer-7',\n                frequency: 14000,\n                q: 1,\n                type: \"highshelf\",\n            },\n        ],\n        track: {\n            bar: '#load-progressbar',\n            head: '#progress-head',\n            mark: '#time-mark',\n        },\n        info: {\n            function: '#progress-info',\n            data: '#progress-percent',\n            name: '#track-name',\n            duration: '#track-time',\n            path: '#track-path',\n        },\n        volume: '#amplifier-volume',\n        balance: '#amplifier-balance',\n        classes: {\n            barTransition: 'progress-bar-transition',\n            pressedKey: 'pressed',\n            activeItem: 'now-playing',\n            failedItem: 'is-failed',\n        },\n        analyser: {\n            offset: 0,\n            maxOpacity: '0.6',\n            leds: [\n                {\n                    selector: '#lvl-20',\n                    thereshold: -20,\n                },\n                {\n                    selector: '#lvl-15',\n                    thereshold: -15,\n                },\n                {\n                    selector: '#lvl-5',\n                    thereshold: -5,\n                },\n                {\n                    selector: '#lvl0',\n                    thereshold: 0,\n                },\n                {\n                    selector: '#lvl3',\n                    thereshold: 3,\n                },\n            ]\n        },\n        codecs: {\n            selector: '#supported-formats',\n        },\n        playlist: {\n            selector: '#playlist',\n            trackHTML: `<li class=\"is-playable\">\n        <div class=\"playlist-name\" data-name></div>\n        <div class=\"playlist-time\" data-time>--:--</div>\n      </li>`,\n            directoryHTML: `<li class=\"is-directory\">\n        <div class=\"playlist-dir\" data-name></div>\n      </li>`,\n            nameFormat: (tagInfo) => {\n                if (tagInfo && tagInfo.tags && (tagInfo.tags.artist || tagInfo.tags.title)) {\n                    return (tagInfo.tags.track ? tagInfo.tags.track + '. ' : '') +\n                        (tagInfo.tags.artist ? tagInfo.tags.artist : '') +\n                        (tagInfo.tags.artist && tagInfo.tags.title ? ' - ' : '') +\n                        (tagInfo.tags.title ? tagInfo.tags.title : '');\n                }\n                return '';\n            },\n        },\n        unsupported: '#unsupported-message',\n        function: {\n            tape: '#f-tape',\n            radio: '#f-radio',\n            aux: '#f-aux',\n        },\n        bassdrivers: {\n            left: \"#left-bassdriver\",\n            right: \"#right-bassdriver\",\n            reset: ['transform', 'scale(1)'],\n            levels: [\n                [-10, 'transform', 'scale(1.05)'],\n            ],\n        },\n        cassetteDeckCase: {\n            selector: '#cassette-deck',\n            openClass: 'open',\n            workingClass: 'working',\n            loadedClass: 'loaded',\n            tapeLeft: '#tape-left',\n            tapeRight: '#tape-right',\n            minTapeWidth: 62,\n            maxTapeWidth: 150,\n            // reelLeft: '#reel-left',\n            // maxReelSpeed: 4,\n            // minReelSpeed: 2,\n        },\n        indicators: {\n            onClass: 'led-on',\n            stereo: '#led-stereo',\n            autostart: '#led-autostart',\n            repeatAll: '#led-all',\n            repeatDir: '#led-dir',\n            repeatTrack: '#led-track',\n        },\n        radio: {\n            prevButton: '#radio-prev',\n            nextButton: '#radio-next',\n            scaleRangeInput: '#radio-scale',\n            wheelOver: '#radio-roatate-wheel',\n            info: '#radio-info',\n            playlist: '#stations',\n            stationHTML: `<li class=\"is-playable\">\n        <div class=\"playlist-name\" data-name></div>\n        <button class=\"playlist-edit\" data-edit title=\"Edit\">✎</button>\n        <button class=\"playlist-remove\" data-remove title=\"Delete\">✕</button>\n      </li>`,\n            updateButton: '#stations-update',\n            form: '#stations-form',\n        },\n        sounds: {\n            tuning: './sounds/tuning.ogg',\n            play: './sounds/play.ogg',\n            stop: './sounds/stop.ogg',\n            pauseOn: './sounds/pause.ogg',\n            pauseOff: './sounds/pause.ogg',\n            otherKeys: './sounds/otherKeys.ogg',\n            cassetteEject: './sounds/cassetteEject.ogg',\n            cassetteLoad: './sounds/cassetteLoad.ogg',\n            buttons: './sounds/buttons.ogg',\n        }\n    });\n});\n\n\n//# sourceURL=webpack:///./src/index.ts?");

/***/ }),

/***/ "./src/types/DeckMode.ts":
/*!*******************************!*\
  !*** ./src/types/DeckMode.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DeckMode\": () => (/* binding */ DeckMode)\n/* harmony export */ });\nvar DeckMode;\n(function (DeckMode) {\n    DeckMode[DeckMode[\"default\"] = 0] = \"default\";\n    DeckMode[DeckMode[\"repeatTrack\"] = 1] = \"repeatTrack\";\n    DeckMode[DeckMode[\"repeatDir\"] = 2] = \"repeatDir\";\n    DeckMode[DeckMode[\"repeatAll\"] = 3] = \"repeatAll\";\n})(DeckMode || (DeckMode = {}));\n\n\n//# sourceURL=webpack:///./src/types/DeckMode.ts?");

/***/ }),

/***/ "./src/types/DeckStates.ts":
/*!*********************************!*\
  !*** ./src/types/DeckStates.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DeckStates\": () => (/* binding */ DeckStates)\n/* harmony export */ });\nvar DeckStates;\n(function (DeckStates) {\n    DeckStates[DeckStates[\"stopped\"] = 0] = \"stopped\";\n    DeckStates[DeckStates[\"playing\"] = 1] = \"playing\";\n    DeckStates[DeckStates[\"paused\"] = 2] = \"paused\";\n    DeckStates[DeckStates[\"busy\"] = 3] = \"busy\";\n})(DeckStates || (DeckStates = {}));\n\n\n//# sourceURL=webpack:///./src/types/DeckStates.ts?");

/***/ }),

/***/ "./src/types/ReceiverStates.ts":
/*!*************************************!*\
  !*** ./src/types/ReceiverStates.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ReceiverStates\": () => (/* binding */ ReceiverStates)\n/* harmony export */ });\nvar ReceiverStates;\n(function (ReceiverStates) {\n    ReceiverStates[ReceiverStates[\"stopped\"] = 0] = \"stopped\";\n    ReceiverStates[ReceiverStates[\"playing\"] = 1] = \"playing\";\n})(ReceiverStates || (ReceiverStates = {}));\n\n\n//# sourceURL=webpack:///./src/types/ReceiverStates.ts?");

/***/ }),

/***/ "./node_modules/worker-loader/dist/cjs.js!./src/worker.js":
/*!****************************************************************!*\
  !*** ./node_modules/worker-loader/dist/cjs.js!./src/worker.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Worker_fn)\n/* harmony export */ });\nfunction Worker_fn() {\n  return new Worker(__webpack_require__.p + \"main.worker.js\");\n}\n\n\n//# sourceURL=webpack:///./src/worker.js?./node_modules/worker-loader/dist/cjs.js");

/***/ }),

/***/ "./src/elements/Slider.js":
/*!********************************!*\
  !*** ./src/elements/Slider.js ***!
  \********************************/
/***/ (() => {

eval("class Slider extends HTMLElement {\n  #shadow;\n  #track;\n  #knob;\n  #trackHeight;\n  #knobHeight;\n  #trackRect;\n  #input;\n  defaultValue;\n  value;\n  min;\n  max;\n  step;\n  pixelValue;\n  moving = false;\n  focused = false;\n  constructor(...args) {\n    super(...args);\n    this.shadow = this.attachShadow({mode: 'open'});\n    this.track = document.createElement('div');\n    this.knob = document.createElement('div');\n    let style = document.createElement('style');\n    this.knob.setAttribute('part', 'knob');\n    this.track.setAttribute('part', 'track');\n    this.input = document.createElement('input');\n    this.input.setAttribute('type', 'hidden');\n    this.input.setAttribute('name', this.getAttribute('name'));\n    this.knob.setAttribute('tabindex', 0);\n    \n    style.textContent = `\n    div {\n      border: none;\n      outline: none;\n      height: 100%;\n      width: 100%;\n      margin: inherit;\n      padding: 0;\n      font-size: 0;\n      box-sizing: content-box;\n      background: transparent;\n      display:flex;\n      justify-content: center;\n      user-select: none;\n    }\n    div>div {\n      border: 1px solid currentColor;\n      height: 10px;\n      width: inherit;\n      cursor: pointer;\n      transform: translateY(0);\n      margin: 0;\n      padding: 0;\n      font-size: 0;\n      box-sizing: border-box;\n      user-select: none;\n    }\n    div>div:focus {\n      outline: 1px solid;\n    }`;\n    this.shadow.appendChild(style);\n    this.track.appendChild(this.knob);\n    this.shadow.appendChild(this.track);\n    this.shadow.appendChild(this.input);\n    \n    this.min = parseFloat(this.getAttribute('min'));\n    this.max = parseFloat(this.getAttribute('max'));\n    this.step = parseFloat(this.getAttribute('step'));\n    if (!this.step) {\n      this.step = 1;\n    }\n    this.defaultValue = this.getAttribute('value');\n    \n    this.setValue(this.defaultValue);\n    \n    let clickTimer;\n    let blockClick = false;\n    let oldValue;\n    this.knob.addEventListener('focus', e => {\n      this.focused = true;\n      oldValue = this.input.value;\n    });\n    this.knob.addEventListener('blur', e => {\n      if (this.focused) {\n        this.focused = false;\n      }\n      if (oldValue !== this.input.value) {\n        this.dispatchEvent(new CustomEvent('change'));\n      }\n    });\n    this.knob.addEventListener('keydown', e => {\n      if (!this.focused) {\n        return;\n      }\n      if (e.key === 'ArrowUp') {\n        e.preventDefault();\n        this.setValue(this.value + parseFloat(this.step));\n        this.dispatchEvent(new CustomEvent('input'));\n        return;\n      }\n      if (e.key === 'ArrowDown') {\n        e.preventDefault();\n        this.setValue(this.value - parseFloat(this.step));\n        this.dispatchEvent(new CustomEvent('input'));\n        return;\n      }\n    }, false);\n    this.knob.addEventListener('mousedown', e => {\n      this.moving = true;\n      this.setValueByCursorPosition(e.clientY);\n    });\n    document.addEventListener('mouseup', e => {\n      if (this.moving) {\n        this.moving = false; \n      }\n    }); \n    document.addEventListener('mousemove', e => {\n      if (!this.moving) {\n        return;\n      }\n      e.preventDefault();\n      blockClick = true;\n      this.setValueByCursorPosition(e.clientY);\n      this.dispatchEvent(new CustomEvent('input'));\n    }, false);\n    this.addEventListener('click', e => {\n      //move to click position\n      clearTimeout(clickTimer);\n      if (blockClick) {\n        return blockClick = false;\n      }\n      clickTimer = setTimeout(() => {\n        this.knob.focus();\n        this.setValueByCursorPosition(e.clientY);\n        this.dispatchEvent(new CustomEvent('input'));\n      }, 400);\n    });\n    this.addEventListener('dblclick', e => {\n      //reset to default\n      clearTimeout(clickTimer);\n      this.knob.focus();\n      this.setValue(this.defaultValue);\n      this.dispatchEvent(new CustomEvent('input'));\n    });\n    this.addEventListener('wheel', e => {\n      //move\n      this.knob.focus();\n      e.preventDefault();\n      if (e.deltaY > 0) {\n        this.setValue(this.value - parseFloat(this.step));\n      } else {\n        this.setValue(this.value + parseFloat(this.step));\n      }\n      this.dispatchEvent(new CustomEvent('input'));\n    });\n    window.addEventListener('resize', () => {\n      requestAnimationFrame(() => this.reDraw());\n    });\n    setTimeout(() => this.reDraw(), 0);\n  }\n  \n  static get observedAttributes() {\n    return ['value', 'max', 'min', 'step', 'style'];\n  }\n  \n  attributeChangedCallback(name, oldValue, newValue) {\n    if (name === 'value') {\n      return this.setValue(newValue);\n    }\n    if (name === 'max') {\n      return this.setMax(newValue);\n    }\n    if (name === 'min') {\n      return this.setMin(newValue);\n    }\n    if (name === 'step') {\n      return this.setStep(newValue);\n    }\n    if (name === 'style') {\n      return this.reDraw();\n    }\n  }\n  \n  setValue(value, forced) {\n    if (value < this.min) {\n      value = this.min;\n    }\n    if (value > this.max) {\n      value = this.max;\n    }\n    if (!forced && this.value == value) {\n      return;\n    }\n    this.value = parseFloat(value);\n    if (this.step) {\n      this.value = Math.round(this.value / parseFloat(this.step)) * parseFloat(this.step);\n    }\n    //this.setAttribute('value', value);\n    let min = parseFloat(this.min);\n    let max = parseFloat(this.max);\n    let pos = this.trackHeight * (1 - (this.value - min) / (max - min));\n    if (pos > this.trackHeight) {\n      pos = this.trackHeight;\n    }\n    this.knob.style.setProperty('transform', `translateY(${pos}px)`);\n    this.input.setAttribute('value', value);\n  }\n  setMin(min) {\n    this.min = min;\n    //this.setAttribute('min', min);\n    this.setValue(this.value);\n    this.pixelValue = (parseFloat(this.max) - parseFloat(this.min)) / this.trackHeight;\n  }\n  setMax(max) {\n    this.max = max;\n    //this.setAttribute('max', max);\n    this.setValue(this.value);\n    this.pixelValue = (parseFloat(this.max) - parseFloat(this.min)) / this.trackHeight;\n  }\n  setStep(step) {\n    this.step = step;\n    //this.setAttribute('step', step);\n    this.setValue(this.value);\n  }\n  \n  setValueByCursorPosition(pos) {\n    let pixelDistance = this.trackRect.bottom - pos - this.knobHeight / 2;\n    let value = parseFloat(this.min) + this.pixelValue * pixelDistance;\n    this.setValue(value);\n  }\n  \n  reDraw() {\n    this.knobHeight = this.knob.offsetHeight;\n    this.trackHeight = this.track.clientHeight - this.knobHeight;\n    this.trackRect = this.track.getBoundingClientRect();\n    this.pixelValue = (parseFloat(this.max) - parseFloat(this.min)) / this.trackHeight;\n    this.setValue(this.value, true);\n  }\n}\ncustomElements.define('range-slider', Slider);\n\n//# sourceURL=webpack:///./src/elements/Slider.js?");

/***/ }),

/***/ "./src/functions/Sec2time.js":
/*!***********************************!*\
  !*** ./src/functions/Sec2time.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(timeInSeconds) {\n  const pad = (num, size) => (num + \"\").padStart(size, \"0\");\n  const hardPad = (num, size) => ('000' + num).slice(size * -1);\n  const time = parseFloat(timeInSeconds).toFixed(3);\n  const hours = Math.floor(time / 60 / 60);\n  const minutes = Math.floor(time / 60) % 60;\n  const seconds = Math.floor(time - minutes * 60);\n\n  return (hours ? (pad(hours, 2) + ':'):'') + pad(minutes, 2) + ':' + hardPad(seconds, 2);\n}\n\n//# sourceURL=webpack:///./src/functions/Sec2time.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;